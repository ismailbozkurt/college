\subsubsection{The House of Mind}

Explicado todo lo anterior, entender esta técnica no supone ninguna dificultad. Esta es la ventaja de haber recorrido el arduo camino para poder llegar hasta aquí. \\
Antes de nada, se muestra el código vulnerable tal y como está en la versión 2.3.5 de la \textit{glibc}. \bigskip

\lstset{language=C, caption=Código vulnerable para The House of Mind (malloc.c:4338) , label=code:house_of_mind_vuln}
\begin{lstlisting}
      /*
        Place the chunk in unsorted chunk list. Chunks are
        not placed into regular bins until after they have
        been given one chance to be used in malloc.
      */

      bck = unsorted_chunks(av);
      fwd = bck->fd;
      p->bk = bck;
      p->fd = fwd;
      bck->fd = p;
      fwd->bk = p;
\end{lstlisting}

En estos momentos, la utilidad de este código es irrelevante. Sólo para situarse, decir que este código viene después de ejecutar la macro \textit{unlink} si el siguiente fragmento no está en uso - la condición |!nextinuse| de la que tanto se ha hablado. \bigskip

Esta técnica se basa en ser capaz de controlar el valor que devuelve la macro |unsorted_chunks()| una vez se le pasa la variable |av| que no es más que un puntero al \textit{arena}. Si se controlara el valor del puntero |bck| es posible que con la penúltima instrucción |bck->fd = p| se pudiera sobrescribir cualquier dirección de memoria tal y como ocurre con la vulnerabilidad \textit{unlink}. Evidentemente, como con la vulnerabilidad \textit{unlink}, debe existir un desbordamiento de búfer que permita sobrescribir el valor del campo |prev_size| \footnote{Debido a que el campo prev\_size es el primer campo de un fragmento de memoria.} del fragmento de memoria |p|. De este modo, controlando |bck->fd| y el contenido de la dirección del puntero |p| se podrán escribir 4 bytes en cualquier dirección de memoria. \\
Como se puede deducir, esta técnica tiene, como mínimo, las mismas precondiciones que la vulnerabilidad \textit{unlink}, sin embargo, aun queda el hecho de que se debe tener el control sobre lo que devuelve la macro |unsorted_chunks()|.\bigskip

El Código \ref{code:unsorted_chunks_macro} muestra la definición de la macro |unsorted_chunks()|. Aunque tampoco es necesario, se muestra cual es el uso de los \textit{unsorted chunks} tal y como está comentado en el código fuente.\bigskip

\lstset{language=C, caption=Macro unsorted\_chunks() (malloc.c:2052) , label=code:unsorted_chunks_macro}
\begin{lstlisting}
/*
  Unsorted chunks

    All remainders from chunk splits, as well as all returned chunks,
    are first placed in the "unsorted" bin. They are then placed
    in regular bins after malloc gives them ONE chance to be used before
    binning. So, basically, the unsorted_chunks list acts as a queue,
    with chunks being placed on it in free (and malloc_consolidate),
    and taken off (to be either used or placed in bins) in malloc.

    The NON_MAIN_ARENA flag is never set for unsorted chunks, so it
    does not have to be taken into account in size comparisons.
*/

/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */
#define unsorted_chunks(M)          (bin_at(M, 1))
\end{lstlisting}

La macro |unsorted_chunks()| no hace más que llamar a la macro |bin_at()| pasándole al array de \textit{bins} un 1. La definición de dicha macro está en el Código \ref{code:bin_at_macro}. \bigskip

\lstset{language=C, caption=Macro bin\_at() (malloc.c:1973) , label=code:bin_at_macro}
\begin{lstlisting}
/* addressing -- note that bin_at(0) does not exist */
#define bin_at(m, i) ((mbinptr)((char*)&((m)->bins[(i)<<1]) - (SIZE_SZ<<1)))
\end{lstlisting}

Reemplazando los parámetros y las constantes se obtiene que la macro |bin_at()| devuelve lo siguiente:

\lstset{language=C, caption=Macro bin\_at() reemplazada, label=code:bin_at_eq_macro}
\begin{lstlisting}
(&((av)->bins[(1)<<1]) - (4<<1))    ==>    &(av->bins[2]) - 8
\end{lstlisting}

Cabe destacar que en versiones más recientes de la \textit{glibc} dicha macro se ve modificada de modo que si se le pasa un 1 a la macro |bin_at| lo que se devuelve es la posición 0 del array de \textit{bins} y no la 2, debido a que la macro está definida tal que así: \bigskip

\lstset{language=C, caption=Nueva macro bin\_at(), label=code:new_bin_at_macro}
\begin{lstlisting}
#define bin_at(m, i) \
  (mbinptr) (((char *) &((m)->bins[((i) - 1) * 2]))                           \
             - offsetof (struct malloc_chunk, fd))
\end{lstlisting}

Con la macro definida de este modo, lo que se dice en los textos \cite{MM} y \cite{MDM} concuerda. Sin embargo, esto es irrelevante para entender cómo funciona la técnica y qué se ha hecho en las nuevas versiones de la \textit{glibc}. \bigskip

La macro |unsorted_chunks()| devuelve la dirección de |av->bins[2]| menos 8 bytes. Volviendo a la definición del \textit{arena}, Código \ref{code:malloc_state_struct}, el array de \textit{bins} está en un offset de ''x'' bytes. El valor exacto no es necesario ahora mismo. Si el atacante fuera capaz de controlar el contenido de la dirección |av->bins[2]| menos 8 bytes sería capaz de controlar el valor del puntero |bck| al volver de la macro |unsorted_chunks()| y escribir en la dirección contenida por el campo |prev_size| del fragmento |p|, presumiblemente la sección .dtors después del desbordamiento. \bigskip

Sin embargo, para poder conseguir esto, se hace evidente que se debe controlar el contenido del \textit{arena}, o sea, la variable |av| que ha entrado en juego durante toda la explicación. Evidentemente, si se controlara el contenido del \textit{arena} se podría controlar el valor que se encuentra en la dirección |av->bins[2]| menos 8 bytes. Pero, evidentemente, a simple vista parece imposible controlar el contenido del \textit{arena}. Sin embargo, en el Código \ref{code:arena_for_chunk} de la página \pageref{code:arena_for_chunk} ya se ha topado con un método para conseguir dicho objetivo. \bigskip

Lo que antes era un problema, ahora se convierte en el vector de ataque. A diferencia de la técnica \textit{unlink}, en vez de crear un fragmento de memoria falso, se va a crear un \textit{arena} falso. Y para ello, se va aprovechar la capacidad de no utilizar el |main_arena|, sino que se buscará un nuevo \textit{arena} a partir de la macro |heap_for_ptr()|. El Código \ref{code:heap_for_ptr_macro} define la macro |heap_for_ptr()|.\bigskip

\lstset{language=C, caption=Macro heap\_for\_ptr() (arena.c:104), label=code:heap_for_ptr_macro}
\begin{lstlisting}
#define heap_for_ptr(ptr) \
 ((heap_info *)((unsigned long)(ptr) & ~(HEAP_MAX_SIZE-1)))
\end{lstlisting}

El valor de |HEAP_MAX_SIZE| es de 1024 * 1024, que en binario es 1000000000000-00000000, por tanto si se le resta 1 se obtiene 11111111111111111111, que negado son 20 ceros. Por tanto, lo que hace la macro |heap_for_ptr()| es poner a 0 los últimos 20 bits - los de menos peso - de la dirección del puntero |ptr|. El \textit{arena} de dicho fragmento de memoria en realidad será la misma dirección devuelta por la macro |heap_for_ptr| ya que en la estructura |heap_info|, Código \ref{code:heap_info_struct}, la primera variable de la estructura es el \textit{arena}. \\
Poniendo un ejemplo, si el fragmento de memoria para el que se quiere saber su \textit{arena}, está ubicado en la dirección 0x0804b208, su \textit{arena} estará en la dirección 0x08000000. Evidentemente, para que se busque el \textit{arena} en vez de utilizar el arena principal, el fragmento de memoria debe tener el bit |NON_MAIN_ARENA| a 1, tal y como se explica en la página \pageref{code:arena_for_chunk}. \bigskip

Ahora que todo está explicado falta saber cual es la pieza que lo encaja todo. La clave de todo esto es entender que los primeros\footnote{Los primeros búfers para los que un programa pide espacio.} fragmentos de memoria en un sistema sin ASLR estarán ubicados en direcciones del estilo 0x080xxxxx y si de este fragmento se buscara su \textit{arena} siempre se obtendrían direcciones de memoria inferiores, con lo que sería imposible sobrescribir los datos del \textit{arena} a través de un desbordamiento de búfer. Sin embargo, si fuera posible tener un fragmento de memoria en direcciones del estilo 0x081xxxxx, se obtendría que su \textit{arena} estaría en la dirección 0x08100000 con lo que a través de un desbordamiento en el fragmento de memoria situado en 0x080xxxxx se podrían sobrescribir los datos del \textit{arena} situado en 0x08100000. \\
He aquí el nuevo requisito de esta técnica. Por un lado se necesitan dos fragmentos de memoria igual que con \textit{unlink}, sin embargo, ahora uno de ellos debe estar ubicado en una dirección del estilo 0x081xxxxx.\bigskip

La Figura \ref{fig:house_of_mind} muestra un gráfico para retratar la idea general de esta técnica. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.85]{./Chapters/HeapExploiting/glibc/malloc_maleficarum/house_of_mind/img/basic_idea.eps}   
    \caption{Idea general sobre la técnica House of Mind}
    \label{fig:house_of_mind}
\end{figure}

Por un lado se tiene que el primer fragmento de memoria será el que se utilizará como falso \textit{arena}. A continuación se sobrescribirán los siguientes fragmentos de memoria hasta llegar a la dirección 0x08100000 donde el primer valor será la dirección al primer fragmento |p1|. De este modo, cuando se libere el segundo fragmento situado en una dirección de memoria del estilo 0x081xxxxx se obtendrá\footnote{Vía la macro heap\_for\_ptr()} que el puntero a su \textit{arena} está en la dirección 0x08100000 donde se encuentra la dirección a |p1| con lo que se engaña al algoritmo de modo que piense que el contenido del \textit{arena} es el contenido del primer fragmento de memoria. Por tanto, se obtiene que con la instrucción |bck = unsorted_chunks(av)|, |bck| apunta a |p1|, el primer fragmento. \\
A continuación se ejecuta la instrucción |bck->fd = p|. |bck->fd| apunta a la sección .dtors, por lo que al ejecutarse esta instrucción la sección .dtors será sobrescrita por la dirección a |p|, que debido a que se está ejecutando el segundo |free()|, |p| apunta al fragmento de memoria situado en la dirección 0x081xxxxx.\\
Una vez el programa finalice, se ejecutarán las instrucciones ubicadas en la dirección 0x081xxxxx tal y como ocurría con la vulnerabilidad del \textit{unlink}, con lo que se ejecutará el |jmp 12| y luego el \textit{shellcode}. \bigskip

Destacar que hay decenas de requisitos que no se han comentado en esta explicación. El uso del bit |NON_MAIN_ARENA|, los offsets exactos donde ubicar las direcciones con las que se trabaja, la dirección exacta en la sección .dtors y muchos otros detalles. Sólo se quería mostrar al lector cómo funciona esta técnica para mostrarle cómo los desarrolladores de la \textit{glibc} han solucionado la vulnerabilidad. Además, al ser la técnica pública más avanzada para explotar el \textit{heap}, nos permitirá realizar ciertas reflexiones sobre cómo continuar investigando las vulnerabilidades en la gestión de la memoria dinámica. \\
Para obtener todos los detalles necesarios para escribir una prueba de concepto utilizando esta técnica basta con leer los artículos citados en \cite{MM}, \cite{THOM} o \cite{MDM}.