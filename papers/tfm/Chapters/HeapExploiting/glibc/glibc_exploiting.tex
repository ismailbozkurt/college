\section{Explotando el algoritmo implementado en la GLIBC}
\label{sec:glibc_exploiting}

Actualmente, las técnicas detalladas en los apartados anteriores están obsoletas. Aunque el algoritmo que se usa sea el mismo, en la implementación existente en la \textit{glibc} se han añadido muchas modificaciones con el objetivo de asegurar la integridad de las estructuras de datos de modo que la explotación del algoritmo se ha vuelto significativamente más compleja. \bigskip

Para mostrar las nuevas medidas de seguridad implementadas en la \textit{glibc}, a continuación se ejecutan las pruebas de concepto detalladas en los apartados anteriores. \bigskip

\begin{listing}[style=consola, caption=Ejecución de la prueba de concepto sin bytes nulos, label=out:crash_pof_1]
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ ./pof_without_null_bytes 
*** glibc detected *** ./pof_without_null_bytes: free(): invalid next size (normal): 0x09515008 ***
======= Backtrace: =========
/lib/libc.so.6(+0x6c501)[0x202501]
/lib/libc.so.6(+0x6dd70)[0x203d70]
/lib/libc.so.6(cfree+0x6d)[0x206e5d]
./pof_without_null_bytes[0x8048703]
/lib/libc.so.6(__libc_start_main+0xe7)[0x1acce7]
./pof_without_null_bytes[0x8048521]
======= Memory map: ========
00194000-00195000 r-xp 00000000 00:00 0          [vdso]
00196000-002ed000 r-xp 00000000 08:01 655498     /lib/libc-2.12.1.so
002ed000-002ee000 ---p 00157000 08:01 655498     /lib/libc-2.12.1.so
002ee000-002f0000 r--p 00157000 08:01 655498     /lib/libc-2.12.1.so
002f0000-002f1000 rw-p 00159000 08:01 655498     /lib/libc-2.12.1.so
002f1000-002f4000 rw-p 00000000 00:00 0 
00b24000-00b3e000 r-xp 00000000 08:01 655532     /lib/libgcc_s.so.1
00b3e000-00b3f000 r--p 00019000 08:01 655532     /lib/libgcc_s.so.1
00b3f000-00b40000 rw-p 0001a000 08:01 655532     /lib/libgcc_s.so.1
00eed000-00f09000 r-xp 00000000 08:01 655474     /lib/ld-2.12.1.so
00f09000-00f0a000 r--p 0001b000 08:01 655474     /lib/ld-2.12.1.so
00f0a000-00f0b000 rw-p 0001c000 08:01 655474     /lib/ld-2.12.1.so
08048000-08049000 r-xp 00000000 08:01 923982     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_without_null_bytes
08049000-0804a000 -w-p 00000000 08:01 923982     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_without_null_bytes
0804a000-0804b000 rw-p 00001000 08:01 923982     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_without_null_bytes
09515000-09516000 rw-p 00000000 00:00 0 
09516000-09517000 -wxp 00000000 00:00 0 
09517000-09537000 rw-p 00000000 00:00 0 
b7700000-b7721000 rw-p 00000000 00:00 0 
b7721000-b7800000 ---p 00000000 00:00 0 
b785f000-b7860000 rw-p 00000000 00:00 0 
b786d000-b786f000 rw-p 00000000 00:00 0 
bfd25000-bfd46000 rw-p 00000000 00:00 0          [stack]
Abortado
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ 
\end{listing}

En el Código \ref{out:crash_pof_1} se ejecuta la primera prueba de concepto en la que no se utilizaban bytes nulos. Como se puede ver el código fuente de la glibc implementa una nueva medida de seguridad por la que el tamaño del siguiente fragmento de memoria al que se va a liberar no es correcto. Esta nueva comprobación se ha añadido en la línea 4306 del archivo malloc.c\footnote{A partir de ahora y hasta que se especifique lo contrario, todas las referencias al código fuente son a los archivos encargados de la gestión de la memoria dinámica de la glibc 2.3.5.}. El Código \ref{code:nextsize_check} muestra dicha comprobación. \bigskip

\lstset{language=C, caption=Comprobación del tamaño del siguiente fragmento (malloc.c:4306) , label=code:nextsize_check}
\begin{lstlisting}
    if (__builtin_expect (nextchunk->size <= 2 * SIZE_SZ, 0)
        || __builtin_expect (nextsize >= av->system_mem, 0))
      {
        errstr = "free(): invalid next size (normal)";
        goto errout;
      }
\end{lstlisting}

En este caso, el tamaño del siguiente fragmento es mayor a |av->system_mem|, por esta razón la prueba de concepto no funciona correctamente.\bigskip

Por otro lado, si se ejecuta la prueba de concepto en la que no existían bytes nulos se obtiene el siguiente resultado. \bigskip

\begin{listing}[style=consola, caption=Ejecución de la prueba de concepto con bytes nulos, label=out:crash_pof_2]
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ ./pof_null_bytes 
*** glibc detected *** ./pof_null_bytes: double free or corruption (!prev): 0x09748008 ***
======= Backtrace: =========
/lib/libc.so.6(+0x6c501)[0x2ae501]
/lib/libc.so.6(+0x6dd70)[0x2afd70]
/lib/libc.so.6(cfree+0x6d)[0x2b2e5d]
./pof_null_bytes[0x8048703]
/lib/libc.so.6(__libc_start_main+0xe7)[0x258ce7]
./pof_null_bytes[0x8048521]
======= Memory map: ========
00110000-0012a000 r-xp 00000000 08:01 655532     /lib/libgcc_s.so.1
0012a000-0012b000 r--p 00019000 08:01 655532     /lib/libgcc_s.so.1
0012b000-0012c000 rw-p 0001a000 08:01 655532     /lib/libgcc_s.so.1
00242000-00399000 r-xp 00000000 08:01 655498     /lib/libc-2.12.1.so
00399000-0039a000 ---p 00157000 08:01 655498     /lib/libc-2.12.1.so
0039a000-0039c000 r--p 00157000 08:01 655498     /lib/libc-2.12.1.so
0039c000-0039d000 rw-p 00159000 08:01 655498     /lib/libc-2.12.1.so
0039d000-003a0000 rw-p 00000000 00:00 0 
0049b000-0049c000 r-xp 00000000 00:00 0          [vdso]
006f7000-00713000 r-xp 00000000 08:01 655474     /lib/ld-2.12.1.so
00713000-00714000 r--p 0001b000 08:01 655474     /lib/ld-2.12.1.so
00714000-00715000 rw-p 0001c000 08:01 655474     /lib/ld-2.12.1.so
08048000-08049000 r-xp 00000000 08:01 924051     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_null_bytes
08049000-0804a000 -w-p 00000000 08:01 924051     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_null_bytes
0804a000-0804b000 rw-p 00001000 08:01 924051     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_null_bytes
09748000-09749000 rw-p 00000000 00:00 0 
09749000-0974a000 -wxp 00000000 00:00 0 
0974a000-0976a000 rw-p 00000000 00:00 0 
b7700000-b7721000 rw-p 00000000 00:00 0 
b7721000-b7800000 ---p 00000000 00:00 0 
b78dd000-b78de000 rw-p 00000000 00:00 0 
b78eb000-b78ed000 rw-p 00000000 00:00 0 
bfbac000-bfbcd000 rw-p 00000000 00:00 0          [stack]
Abortado
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ 
\end{listing}

En este caso, se comprueba la integridad de las estructuras de datos y, a tal efecto, se comprueba si el siguiente fragmento a liberar tiene el bit |PREV_INUSE| a 0. De ser así, evidentemente se han corrompido las estructuras ya que dicho bit debería estar a 1 debido a que el fragmento a liberar - el anterior al de esta comprobación - está en uso. esta comprobación se ha añadido en la línea 4299 del archivo malloc.c tal y como se muestra en el Código \ref{code:previnuse_check}. \bigskip

\lstset{language=C, caption=Comprobación del prev\_inuse siguiente fragmento (malloc.c:4299) , label=code:previnuse_check}
\begin{lstlisting}
    /* Or whether the block is actually not marked used.  */
    if (__builtin_expect (!prev_inuse(nextchunk), 0))
      {
        errstr = "double free or corruption (!prev)";
        goto errout;
      }
\end{lstlisting}

Si se conoce el funcionamiento del algoritmo, la evasión de las medidas de seguridad que se han mostrado es trivial, sin embargo, existe otra medida de seguridad implementada directamente en la macro \textit{unlink} que hace que el proceso de desenlazado de un fragmento de memoria sea mucho más robusto. \\
El Código \ref{out:crash_pof_3} muestra la ejecución de una nueva prueba de concepto que implementa un \textit{payload} diferente. En este caso, en vez de utilizar un \textit{offset} negativo para situar el fragmento de memoria falso, se ha utilizado un \textit{offset} positivo de modo que se evadan las medidas de seguridad mostradas. Si el lector ha entendido todos los conceptos explicados hasta el momento, no tendrá ningún problema para desarrollar él mismo dicha prueba de concepto. \bigskip

\begin{listing}[style=consola, caption=Ejecución de la prueba de concepto con offset positivo, label=out:crash_pof_3]
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ ./pof_positive_offset 
*** glibc detected *** ./pof_positive_offset: corrupted double-linked list: 0x088c4208 ***
======= Backtrace: =========
/lib/libc.so.6(+0x6c501)[0xb50501]
/lib/libc.so.6(+0x6de33)[0xb51e33]
/lib/libc.so.6(cfree+0x6d)[0xb54e5d]
./pof_positive_offset[0x8048739]
/lib/libc.so.6(__libc_start_main+0xe7)[0xaface7]
./pof_positive_offset[0x8048521]
======= Memory map: ========
00839000-0083a000 r-xp 00000000 00:00 0          [vdso]
00a74000-00a8e000 r-xp 00000000 08:01 655532     /lib/libgcc_s.so.1
00a8e000-00a8f000 r--p 00019000 08:01 655532     /lib/libgcc_s.so.1
00a8f000-00a90000 rw-p 0001a000 08:01 655532     /lib/libgcc_s.so.1
00ae4000-00c3b000 r-xp 00000000 08:01 655498     /lib/libc-2.12.1.so
00c3b000-00c3c000 ---p 00157000 08:01 655498     /lib/libc-2.12.1.so
00c3c000-00c3e000 r--p 00157000 08:01 655498     /lib/libc-2.12.1.so
00c3e000-00c3f000 rw-p 00159000 08:01 655498     /lib/libc-2.12.1.so
00c3f000-00c42000 rw-p 00000000 00:00 0 
00f29000-00f45000 r-xp 00000000 08:01 655474     /lib/ld-2.12.1.so
00f45000-00f46000 r--p 0001b000 08:01 655474     /lib/ld-2.12.1.so
00f46000-00f47000 rw-p 0001c000 08:01 655474     /lib/ld-2.12.1.so
08048000-08049000 r-xp 00000000 08:01 923969     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_positive_offset
08049000-0804a000 -w-p 00000000 08:01 923969     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_positive_offset
0804a000-0804b000 rw-p 00001000 08:01 923969     /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_positive_offset
088c4000-088c5000 rw-p 00000000 00:00 0 
088c5000-088c6000 -wxp 00000000 00:00 0 
088c6000-088e5000 rw-p 00000000 00:00 0 
b7600000-b7621000 rw-p 00000000 00:00 0 
b7621000-b7700000 ---p 00000000 00:00 0 
b7712000-b7713000 rw-p 00000000 00:00 0 
b7720000-b7722000 rw-p 00000000 00:00 0 
bfccd000-bfcee000 rw-p 00000000 00:00 0          [stack]
Abortado
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ 
\end{listing}

De nuevo, se produce un error. Pero este error se debe a una comprobación que parece que soluciona todos los problemas que introduce la macro \textit{unlink}. El Código \ref{code:unlink_check} muestra dicha comprobación. \bigskip

\lstset{language=C, caption=Comprobación en la macro unlink (malloc.c:1986) , label=code:unlink_check}
\begin{lstlisting}
/* Take a chunk off a bin list */
#define unlink(P, BK, FD) {                                           \
  FD = P->fd;                                                         \
  BK = P->bk;                                                         \
  if (__builtin_expect (FD->bk != P || BK->fd != P, 0))               \
   malloc_printerr (check_action, "corrupted double-linked list", P); \
  else {                                                              \
    FD->bk = BK;                                                      \
    BK->fd = FD;                                                      \
  }                                                                   \
}
\end{lstlisting}

Esta comprobación es tan compleja de evadir porque comprueba la integridad de los fragmentos de memoria involucrados en el proceso de \textit{unlink} y comprueba la integridad de los punteros que se sobrescriben para realizar la explotación.\\
Para entender esta comprobación basta con volver a estudiar la Figura \ref{fig:initial_eight_chunks} de la página \pageref{fig:initial_eight_chunks}. En dicha figura es el fragmento 3 el que se va a desenlazar con la macro \textit{unlink}. Si se siguen los punteros, se podrá comprobar como las condiciones de la línea 5 del Código \ref{code:unlink_check} no se cumplen ya que |FD->bk| y |BK->fd| apuntan a |P|. En la Figura \ref{fig:initial_eight_chunks} se cumplen dichos parámetros ya que el campo |bk| del fragmento 6 y el campo |fd| del fragmento 1 apuntan al fragmento 3, o sea, lo que sería |P|. \\
En cambio, si se intenta explotar el algoritmo tal y como se ha explicado en los apartados anteriores, el campo |fd| del fragmento |P| apuntaría a la sección .dtors con lo que |P->fd->bk|, o sea, |FD->bk| no apuntaría a |P| y, por otro lado, el campo |bk| del fragmento |P| apuntaría al \textit{shellcode} con lo que |BK->fd| no apuntaría a |P|. \bigskip

Podría existir un modo de evadir esta medida de seguridad, sin embargo, posiblemente sólo podría ser una prueba de concepto ya que no sería posible extrapolar dicha técnica a un \textit{exploit} real. Este tema se trata con más énfasis en el capítulo \ref{sec:about_unlink}. \bigskip

\pagebreak

\input{./Chapters/HeapExploiting/glibc/malloc_maleficarum/malloc_maleficarum.tex}