\subsection{Evolución de la técnica}

Por otro lado, sería correcto justificar porqué las técnicas detalladas en los artículos citados anteriormente ya no funcionan. \\
La metodología que se explicaba en ellos era muy parecida a la detallada en el capítulo anterior, sin embargo, a parte de otras diferencias más sutiles, en esos artículos en vez de sobrescribir el campo |size| del segundo fragmento con un -15 (a efectos prácticos el tamaño es de -16 bytes) lo sobrescribían con un -4, en hexadecimal, 0xfffffffc. \\
Actualmente, si se utiliza dicho valor, la macro \textit{unlink} se ejecuta en el primer |free()|, sin embargo, cuando se está liberando el segundo fragmento de memoria, el que contiene el -4 en el campo |size|, el programa termina su ejecución recibiendo un |SIGSEGV|, o sea, realizando una violación de segmento cuando se ejecuta la macro |arena_for_chunk()| en [malloc:3405]. \bigskip

Esto se debe a que el valor -4, en hexadecimal es 0xfc lo que en binario es 1111 0110. El segundo conjunto de 4 bits contiene el bit |NON_MAIN_ARENA| a 1. Este dato es relevante debido a que la macro |arena_for_chunk()| se define del siguiente modo: \bigskip

\lstset{language=C, caption=Macro arena\_for\_chunk() , label=code:arena_for_chunk}
\begin{lstlisting}
#define arena_for_chunk(ptr) \
 (chunk_non_main_arena(ptr) ? heap_for_ptr(ptr)->ar_ptr : &main_arena)
\end{lstlisting}

Se comprueba si el fragmento de memoria pertenece al arena principal a partir de la macro |chunk_non_main_arena()|, definida como: \bigskip

\lstset{language=C, caption=Macro chunk\_non\_main\_arena() , label=code:chunk_non_main_arena}
\begin{lstlisting}
/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
   from a non-main arena.  This is only set immediately before handing
   the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* check for chunk from non-main arena */
#define chunk_non_main_arena(p) ((p)->size & NON_MAIN_ARENA)
\end{lstlisting}

Como se puede ver, la macro devolverá un valor diferente a uno si el campo |size| del fragmento de memoria tiene el bit |NON_MAIN_ARENA| a 1. \\
Tal y como ya se ha dicho, si el campo size contiene un -4, el bit |NON_MAIN_ARENA|, que en binario es 0100, estará a uno con lo que la condición será positiva y se ejecutará la macro |heap_for_ptr()| en vez de devolver la dirección del arena principal tal y como debería ocurrir. \\
Acto seguido, cuando se obtiene el puntero al arena a través de dicha macro, se intenta obtener el campo |size|, pero debido a que dicho puntero no es correcto, se acaba incurriendo en una violación de segmento. \bigskip

La única explicación lógica a este error publicado en los artículos citados es que en la época en la que se publicaron el algoritmo \textit{ptmalloc} no implementaba el uso de diferentes arenas sino que siempre operaba sobre el mismo arena. Evidentemente, con la introducción del uso de más de un arena la técnica se volvió obsoleta tal y como se demuestra con el Código \ref{out:pof_obsolete}. \bigskip

\begin{listing}[style=consola, caption=Ejecución con el campo size a -4, label=out:pof_obsolete]
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ gdb -q pof_without_null_bytes
Leyendo símbolos desde /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_without_null_bytes...hecho.
(gdb) r
Starting program: /home/newlog/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test/pof_without_null_bytes 

Program received signal SIGSEGV, Segmentation fault.
0x0013087e in free (mem=0x804b210) at malloc.c:3405
3405	  ar_ptr = arena_for_chunk(p);
(gdb) x/3x 0x804b208
0x804b208:	0x40404041	0xfffffffc	0x08049f10
(gdb) 
\end{listing}

Como se puede ver, el puntero |mem| apunta a la dirección 0x804b210. Si a dicha dirección se le restan 8 bytes se obtiene la dirección del fragmento de memoria |p|\footnote{El valor del puntero p ha sido obtimizado por gdb, por esta razón no se obtiene su contenido con x/3x p.}. Como se puede ver, el campo |prev_size| del fragmento contiene el valor 0x40404041, que se ha sobrescrito con el desbordameinto, y el campo size contiene el valor 0xfffffffc, -4. Debido a lo explicado, este valor hace que el programa termine al ejecutar la macro |arena_for_chunk|.