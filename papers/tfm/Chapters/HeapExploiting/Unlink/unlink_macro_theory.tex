\subsection{Teoría sobre la macro unlink}

La vulnerabilidad que se va a estudiar en estos capítulos pasa por la macro \textit{unlink}.\\
Dicha macro se utiliza cuando se libera un fragmento de memoria que está en uso. Siendo aun más específicos, la macro unlink se ejecuta cuando se libera un fragmento de memoria que está en uso y cuando el fragmento de memoria anterior o siguiente está libre. De este modo se consigue, tal y como se ha explicado en la página \pageref{par:adjacent_chunks}, que diferentes fragmentos de memoria libres adyacentes se consoliden en un solo fragmento de memoria libre mayor. \bigskip

La macro unlink está definida en el archivo malloc.c en la línea 1975 del siguiente modo:

\lstset{language=C, caption=Macro unlink (malloc.c:1975), label=code:unlink_macro}
\begin{lstlisting}
/* Take a chunk off a bin list */
#define unlink(P, BK, FD) {     \
  FD = P->fd;                   \
  BK = P->bk;                   \
  FD->bk = BK;                  \
  BK->fd = FD;                  \
}
\end{lstlisting}

Lo primero a tener en cuenta antes de proseguir es que los fragmentos de memoria del algoritmo original \textit{ptmalloc} no son iguales a los fragmentos de memoria estudiados en el apartado anterior. A diferencia de los fragmentos de memoria implementados en la \textit{glibc}, en el algoritmo que estudiamos no existen los últimos dos campos detallados para un fragmento de memoria libre. Los campos que hacen de punteros al fragmento anterior y siguiente de mayor tamaño no existen. Por esta razón la macro unlink no hace ninguna gestión con ellos, simplemente trabaja con el puntero al siguiente fragmento libre [|P->fd|] y el puntero al fragmento libre anterior [|P->bk|]. \bigskip

Un fragmento de memoria está definido tal que así\footnote{Los comentarios en el código se han movido de lugar debido a cuestiones de formato del documento.}:

\lstset{language=C, caption=malloc\_chunk (malloc.c:1682), label=code:malloc_chunk_ptmalloc}
\begin{lstlisting}
struct malloc_chunk {
  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      prev_size; 
  /* Size in bytes, including overhead. */
  INTERNAL_SIZE_T      size;      

  /* double links -- used only if free. */
  struct malloc_chunk* fd;        
  struct malloc_chunk* bk;
};
\end{lstlisting}

Básicamente la vulnerabilidad que se estudiará a continuación se da debido a que los datos de control que permiten gestionar los fragmentos de memoria son adyacentes a los datos del usuario. Si existieran dos fragmentos de memoria en uso, se estructurarían en memoria tal y como se muestra en la figura \ref{fig:two_allocated_chunks}. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.8]{./Chapters/HeapExploiting/Unlink/img/two_allocated_chunks.eps}   
    \caption{Dos fragmentos de memoria en uso}
    \label{fig:two_allocated_chunks}
\end{figure}

Si en el código fuente de un usuario de esta librería existiera un \textit{buffer overflow} de modo que se desbordaran los datos que se almacenan en el primer fragmento de memoria, se podrían sobrescribir los datos de control \textit{prev\_size} y \textit{size} de modo que una vez el algoritmo los utilizara obtendría unos valores incorrectos.\bigskip

Así pues, es esta capacidad de sobrescribir los datos inherentes al algoritmo lo que propicia que un atacante pueda ser capaz de ejecutar código arbitrario. \bigskip

La macro \textit{unlink} se utiliza cuando al liberarse un fragmento de memoria en uso, existe al menos otro fragmento de memoria libre que es adyacente al fragmento de memoria a liberar [malloc.c:4244]. De este modo, el algoritmo junta - o consolida - lo que serán dos - o tres - fragmentos de memoria libres en un solo fragmento de memoria libre mayor. Gracias a esto se evita una mayor fragmentación interna de los fragmentos de memoria libres. \\
Si el fragmento libre es anterior al que se va a liberar, esta operación se conoce como \textit{consolidate backward}, si el fragmento libre es el siguiente al que se va a liberar se conoce como \textit{consolidate forward}. \bigskip

Específicamente, la macro \textit{unlink} sirve para desenlazar un fragmento de memoria libre de la lista doblemente enlazada de fragmentos de memoria libres que se detalló en la página \pageref{par:bins}. La lógica del algoritmo es simple, si existe algún tipo de consolidación, ya sea \textit{backward} o \textit{forward}, el fragmento de memoria que ya estaba libre se elimina de la lista de \textit{bins} y se fusiona\footnote{Una fusión entre dos fragmentos de memoria libre, básicamente, se consigue a través de modificar el campo \textit{size} del fragmento.} con el fragmento de memoria que se acaba de liberar. Una vez se ha realizado dicha fusión, el fragmento de memoria libre resultante se vuelve a añadir a la lista de \textit{bins}\footnote{Cabe destacar que el nuevo fragmento de memoria se añadirá a un conjunto de \textit{bins} denominado \textit{unsorted chunks}. Esto se debe a cuestiones de optimización ajenas al tema que nos concierne.}, en su debida posición debido al nuevo tamaño del fragmento. \bigskip

A continuación se representa un caso en particular para acabar de definir gráficamente el proceso de desenlace realizado por \textit{unlink}. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.8]{./Chapters/HeapExploiting/Unlink/img/initial_eight_chunks.eps}   
    \caption{Estado anterior a unlink}
    \label{fig:initial_eight_chunks}
\end{figure}

En la Figura \ref{fig:initial_eight_chunks} se representan ocho fragmentos de memoria que son contiguos entre ellos físicamente. Este ejemplo se ha representado con ocho fragmentos de memoria para intentar representar lo que podría ser un caso real donde la macro \textit{unlink} se ejecutara. Evidentemente, aquellos fragmentos que contienen el campo |bk| y el campo |fd| son fragmentos de memoria libres, mientras que los demás son fragmentos de memoria en uso. Como se puede apreciar, en el estado inicial no existen dos fragmentos de memoria libres contiguos ya que tal y como se ha comentado anteriormente - y se detallará posteriormente - dos fragmentos de memoria libres contiguos se fusionan entre ellos. Los punteros |bk| y |fd| apuntan al anterior y al siguiente fragmento de memoria libre respectivamente tal y como se ejemplifica con las flechas. \bigskip

En este caso el fragmento número 4 es que el que se quiere liberar mediante una llamada a |free()|. Tal y como se ve, el fragmento de memoria previo a 4 no está en uso, está libre. Es en este caso cuando el algoritmo ejecuta la macro \textit{unlink} [malloc:4244]. Para saber si el fragmento anterior a 4 está libre, el algoritmo ejecuta la macro |prev_inuse()| que simplemente comprueba si el campo |SIZE| del fragmento 4 tiene el bit |PREV_INUSE| a 1. Si dicho bit está a 0 significa que el fragmento anterior a 4 está libre, entonces se busca en qué dirección de memoria se encuentra el fragmento anterior a partir de la macro |chunk_at_offset()| que utilizando el campo |PREV_SIZE| del fragmento actual a liberar es capaz de obtener la dirección inicial del fragmento anterior - restándole al puntero del fragmento actual el valor de su campo |PREV_SIZE| -. Una vez se conoce cual es la dirección de memoria del fragmento anterior a 4, se puede ejecutar la macro \textit{unlink} sobre él. \bigskip

La macro \textit{unlink} se encarga de desenlazar de la lista de fragmentos libres el fragmento sobre el que actúa, o sea que a efectos prácticos, se encarga de que ningún fragmento de memoria libre apunte al fragmento de memoria desenlazado. Así pues, los punteros |fd| y |bk| de los fragmentos libres que apuntan al fragmento sobre el que actúa \textit{unlink} - representados por las líneas discontinuas - serán modificados para que apunten a otros fragmentos de memoria. \bigskip

Analizando línea a línea la macro \textit{unlink} se podrá ver cómo la estructura final de los fragmentos de memoria será la representada en la Figura \ref{fig:final_eight_chunks}. \bigskip

\lstset{language=C, caption=Macro unlink. Líneas 1 y 2 , label=code:unlink_macro_l1_l2}
\begin{lstlisting}
  FD = P->fd;                   \
  BK = P->bk;                   \
\end{lstlisting}

En el Código \ref{code:unlink_macro_l1_l2} con la línea 1, en |FD| se almacena la dirección del fragmento 6 que es el siguiente fragmento libre de 4. En BK se almacena la dirección del fragmento 1. \bigskip

\lstset{language=C, caption=Macro unlink. Línea 3 , label=code:unlink_macro_l3}
\begin{lstlisting}
  FD->bk = BK;                  \
\end{lstlisting}

A continuación, en la línea 1 del Código \ref{code:unlink_macro_l3} se hace que en el campo |bk| del fragmento 6 (|FD|) se almacene la dirección de memoria donde se ubica el fragmento 1 (|BK|). \bigskip

\lstset{language=C, caption=Macro unlink. Línea 4 , label=code:unlink_macro_l4}
\begin{lstlisting}
  BK->fd = FD;                  \
\end{lstlisting}

Por último, en la línea 1 del Código \ref{code:unlink_macro_l4} se hace que en el campo |fd| del fragmento 1 (|BK|) se almacene la dirección de memoria donde se ubica el fragmento 6 (|FD|). \bigskip

De este modo los punteros |fd| y |bk| de los fragmentos 1 y 6 respectivamente, que anteriormente apuntaban al fragmento 3 han dejado de apuntar a dicho fragmento y ahora apuntan al fragmento 6 y 1 respectivamente. Finalmente, el fragmento 3 se ha desenlazado de la lista de fragmentos libres mediante \textit{unlink}.\\
Cabe destacar que después de que esto ocurra, el fragmento 3 y 4 que ahora son dos fragmentos libres contiguos se consolidan en un solo fragmento libre [malloc.c:4281] de modo que se pierde cualquier referencia a lo que anteriormente era el fragmento 4. Además, este nuevo fragmento [3] también se añade a una lista de fragmentos libres llamada \textit{unsorted\_chunks} [malloc:4274]. \\
El resultado final de esta operación se puede apreciar en la Figura \ref{fig:final_eight_chunks}. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.8]{./Chapters/HeapExploiting/Unlink/img/final_eight_chunks.eps}   
    \caption{Estado posterior a unlink}
    \label{fig:final_eight_chunks}
\end{figure}

Por último, para no sólo tratar con un caso complejo de \textit{unlink}, la Figura \ref{fig:basic_unlink} muestra la funcionalidad básica de \textit{unlink} dados tres fragmentos de memoria libres dentro de la lista doblemente enlazada de \textit{bins}. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.6]{./Chapters/HeapExploiting/Unlink/img/basic_unlink.eps}   
    \caption{Unlink básico}
    \label{fig:basic_unlink}
\end{figure}