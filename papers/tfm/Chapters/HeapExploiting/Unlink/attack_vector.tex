\subsection{Vector de ataque}
\label{sec:attack_vector}

Partiendo de la definición de un fragmento de memoria |malloc_chunk| tal y como se define en el Código \ref{code:malloc_chunk_def}: \bigskip

\lstset{language=C, caption=Definición de un fragmento de memoria , label=code:malloc_chunk_def}
\begin{lstlisting}
struct malloc_chunk {

  INTERNAL_SIZE_T      prev_size;
  INTERNAL_SIZE_T      size;       

  struct malloc_chunk* fd;   
  struct malloc_chunk* bk;
};
\end{lstlisting}

Se deduce que instanciando un puntero |p| de tipo |malloc_chunk|, las direcciones equivalentes para acceder a cada uno de sus elementos son las siguientes: \bigskip

\lstset{language=C, caption=Equivalencias entre punteros , label=code:malloc_chunk_eq}
\begin{lstlisting}
p->prevsize    equivale a    *p + 0  bytes
p->size        equivale a    *p + 4  bytes
p->fd          equivale a    *p + 8  bytes
p->bk          equivale a    *p + 12 bytes
\end{lstlisting}

El Código \ref{code:malloc_chunk_eq} significa, por ejemplo, que para acceder al valor del campo |fd| se debe obtener la dirección donde apunta el puntero |p| y sumarle 8 bytes. Si |p| apuntara a la dirección 0x8111110, el campo |fd| estaría situado en la dirección 0x8111118.\\
Una vez aclarado lo anterior, uno podría analizar cual es el comportamiento de la macro \textit{unlink} a nivel de punteros: \bigskip

\lstset{language=C, caption=Unlink a nivel de punteros , label=code:unlink_pointer_level}
\begin{lstlisting}
FD = P->fd;   equivale a    FD = *P + 8
BK = P->bk;   equivale a    BK = *P + 12
FD->bk = BK;  equivale a    FD + 12 = BK
BK->fd = FD;  equivale a    BK + 8 = FD
\end{lstlisting}

Suponiendo que |FD| y |BK| son punteros en C, con la línea 1 se obtendría que |FD| apunta al contenido de la dirección del fragmento de memoria |p| más 8 bytes, o sea, a la dirección que contiene del campo |fd| del fragmento de memoria (|p->fd|). La segunda línea es análoga a la primera. \\
La línea número 3, la más relevante de todas, realiza una escritura en memoria. La parte izquierda del operando significa que al contenido de la dirección de memoria |*p| + 8 se le suman 12 bytes. Esto significa que si la dirección de memoria ubicada en |*p| + 8 es 0x8000000, pasará a ser 0x800000c\footnote{Dicha suma no será permanente sino que simplemente se utiliza para llevar a cabo la asignación de la parte derecha del operando.}. Con la parte derecha del operando se establece que en dicha dirección de memoria (en el ejemplo, 0x800000c) se escribirá el contenido de la dirección de memoria |*p| + 12, o sea, en |p->bk|.
\paragraph*{}\label{ref:shellcode_overwrite}
Por último, con la cuarta línea también se realiza una escritura en memoria, sin embargo, esta escritura es una molestia que se deberá solventar. Análogamente a la línea 3, al contenido de |*p + 12| se le suma 8, con lo que si en |*p + 12| había un 0x8000000, se obtendrá un 0x8000008. Acto seguido, en esa dirección de memoria (en el ejemplo, 0x8000008) se almacenará el contenido de la dirección de memoria |*p + 8|, o sea, el contenido de |p->fd|. \bigskip

Entonces, ¿cuál es el vector de ataque? El vector de ataque del que se aprovecha esta técnica es la escritura en memoria que se realiza en la línea 3. \\
Realizando una construcción lógica hacia atrás se analiza dicha escritura. Lo primero es que lo que se escribe en memoria es |BK|, que no es más que el contenido de la dirección de memoria de *p + 12, que haciéndolo aun más abstracto es el contenido del campo |bk| del fragmento de memoria que se pasa a \textit{unlink}, o sea, el contenido de |p->bk|. \\
Lo siguiente a analizar es dónde se escribe. Básicamente, se escribe en la dirección de memoria más 12 ubicada en |FD| que es *p + 8 y, de nuevo, haciéndolo más abstracto, es el contenido del campo |fd| del fragmento de memoria que se le pasa a \textit{unlink}, o sea, |p->fd|. \bigskip

Resumiendo: 
\begin{itemize}
\item Qué se escribe en memoria? $\longrightarrow$ El contenido de |p->bk|
\item En qué dirección de memoria se escribe? $\longrightarrow$ En la dirección contenida en |p->fd| + 12 bytes.
\end{itemize}
\paragraph*{}\label{ref:first_question}
Llegados a este punto uno debe plantearse dos cosas. La primera de ellas es si, como usuario de la librería, es posible controlar el contenido de los campos |bk| y |fd| de un framento de memoria libre. La segunda es si, de ser posible lo anterior, cuales serían las repercusiones.\\
A la primera pregunta se le dará respuesta en los próximos apartados, sin embargo, se avanza al lector que, cumpliéndose ciertos requisitos, sí es posible controlar el valor de dichos campos. \\
En cuanto a la segunda cuestión, las repercusiones dependen de las posibilidades. Es de sobra conocido que si un \textit{hacker} tiene la posibilidad de escribir 4 bytes en cualquier dirección de memoria, será capaz de ejecutar código arbitrario\footnote{Dadas las condiciones de sistema que se especifican en esta investigación.}. Lo que como repercusión, es una consecuencia nefasta para el sistema afectado. \\
Si el lector no conoce las técnicas por las cuales se puede conseguir la ejecución de código arbitrario a partir de la escritura de 4 bytes en cierta dirección de memoria, se le encomienda leer el Apéndice \ref{ap:II}.