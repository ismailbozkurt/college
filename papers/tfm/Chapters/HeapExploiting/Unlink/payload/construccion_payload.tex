\subsubsection{Construcción del payload}

El \textit{payload} es el conjunto de datos o bytes con el cual será posible vulnerar el algoritmo \textit{ptmalloc}. Este \textit{payload} se almacenará en el primer búfer, |ptr_1|, y debido a que su tamaño será mayor a 512 bytes, sobrescribirá la región de memoria donde se ubica el segundo búfer, |ptr_2|. Evidentemente, se supone que |ptr_1| y |ptr_2| se almacenan de manera contigua en memoria y dado que en el Código \ref{code:vulnerable_code} se pide espacio para |ptr_1| y acto seguido para |ptr_2| sin que haya ninguna otra petición de espacio de por medio, ni ningún fragmento de memoria libre disponible, los dos búfers se almacenarán de modo adyacente.

\begin{center}
\fbox{
\begin{minipage}[b][\height]{0.95\textwidth}
La idea en la que se basa la explotación de esta vulnerabilidad pasa por hacer creer al algoritmo que el primer búfer a liberar es adyacente a otro fragmento de memoria libre. Si esto es así, la macro \textit{unlink} se ejecutará con lo que será posible escribir 4 bytes en cualquier región de memoria.
\end{minipage}
}
\end{center}

La parte vulnerable del código fuente es la que se representa en el Código \ref{code:ptmalloc_vulnerable} \bigskip

\lstset{language=C, caption=Código \textit{ptmalloc} vulnerable , label=code:ptmalloc_vulnerable}
\begin{lstlisting}
(...)

else if (!chunk_is_mmapped(p)) {
      nextchunk = chunk_at_offset(p, size);
      nextsize = chunksize(nextchunk);
      assert(nextsize > 0);

      /* consolidate backward */
      if (!prev_inuse(p)) {
        prevsize = p->prev_size;
        size += prevsize;
        p = chunk_at_offset(p, -((long) prevsize));
        unlink(p, bck, fwd);
      }

      if (nextchunk != av->top) {
        /* get and clear inuse bit */
        nextinuse = inuse_bit_at_offset(nextchunk, nextsize);

        /* consolidate forward */
        if (!nextinuse) {
          unlink(nextchunk, bck, fwd);
          size += nextsize;
        } else
          clear_inuse_bit_at_offset(nextchunk, 0);
(...)
\end{lstlisting}

Aclarar que para que el Código \ref{code:ptmalloc_vulnerable} se ejecute, se debe ejecutar la función |free()| del programa vulnerable. Todo el razonamiento seguido a continuación, se basa en que se ejecuta la función |free()| sobre el primer búfer, |ptr_1|. \bigskip

Tal y como se ha comentado, se debe engañar al algoritmo para que entre en la condición de la línea 21 aun cuando el siguiente fragmento de memoria al que se está liberando esté en uso. Para engañar al algoritmo, se debe estudiar cómo se decide si el siguiente fragmento de memoria libre al que se está liberando está libre o, en caso contrario, está en uso. \\
La macro que se encarga de definir si un fragmento de memoria está en uso o está libre es la siguiente: \bigskip

\lstset{language=C, caption=Macro inuse\_bit\_at\_offset() , label=code:inuse_bit_at_offset_macro}
\begin{lstlisting}
#define inuse_bit_at_offset(p, s)\
 (((mchunkptr)(((char*)(p)) + (s)))->size & PREV_INUSE)
\end{lstlisting}

A la macro |inuse_bit_at_offset| se le pasa un puntero |p|. A este puntero se le añade un offset |s|. Después de realizar esta acción, la dirección de memoria |p+s| debe coincidir con un fragmento de memoria. Se obtiene el campo |size| de dicho fragmento y se le realiza una |and| lógica con el valor |PREV_INUSE| que es 1. Con lo que si el último bit del campo |size| de un fragmento de memoria es 1, el fragmento de memoria está en uso, si es 0, el fragmento está libre. \\
Volviendo al Código \ref{code:ptmalloc_vulnerable}, en la línea 18 se ejecuta la macro |inuse_bit_at_offset|, sin embargo como parámetros se le pasan las variables |nextchunk| y |nextsize|. Dichas variables se inicializan en las líneas 4 y 5 respectivamente. \\
La macro |chunk_at_offset()| está definida del siguiente modo: \bigskip

\lstset{language=C, caption=Macro chunk\_at\_offset() , label=code:chunk_at_offset_macro}
\begin{lstlisting}
/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
\end{lstlisting}

Con lo que si a la macro se le pasa el puntero |p|, que apunta al primer fragmento a liberar y un tamaño |size| que es el tamaño del propio fragmento a liberar, devolverá un puntero al siguiente fragmento en memoria contiguo al que se va a liberar. En el caso de estudio, si |p| apunta al fragmento de memoria que almacena los datos de |ptr_1|, el siguiente fragmento de memoria es |ptr_2|. De este modo se obtiene la variable |nextchunk| en la línea 4 del Código \ref{code:ptmalloc_vulnerable}. \\
Por otro lado, la variable |nextsize| se inicializa a partir de la macro |chunksize()| a la que se le pasa como parámetro la variable |nextchunk|. Dicha macro definida en el Código \ref{code:chunksize_macro} obtiene el campo |size| del fragmento de memoria que se le pasa. Evidentemente, al campo |size| se le eliminan los 3 bits de menor peso que sirven como metadatos. En el caso de estudio, se obtiene el tamaño del siguiente fragmento de memoria al fragmento a liberar, o sea, el fragmento de memoria que contiene los datos de |ptr_2|.\bigskip

\lstset{language=C, caption=Macro chunksize() , label=code:chunksize_macro}
\begin{lstlisting}
/* Get size, ignoring use bits */
#define chunksize(p)         ((p)->size & ~(SIZE_BITS))
\end{lstlisting}

Se ha seguido todo este razonamiento para que el lector no tenga que creer ciegamente lo que aquí está escrito, sino que pueda comprobar el razonamiento a partir del código expuesto. \\
La primera conclusión a la que se llega pues, es que el campo |size| del fragmento de memoria contiguo al fragmento de memoria que se esta liberando debe tener el bit menos significativo a 0, de este modo se entrará a la condición de la línea 21 del Código \ref{code:ptmalloc_vulnerable}. \bigskip

¿Pero cómo se puede conseguir esto? A través del desbordamiento del que se ha hablado anteriormente. Si el búfer |ptr_1| tiene un tamaño de 512 bytes, si en él se escriben más de esos bytes, los datos acabarán sobreescribiendo el búfer |ptr_2| y a partir de esto y partiendo de la base de que los datos del primer búfer los puede controlar el usuario, es posible escribir en el campo |size| un valor que contenga su bit de menor peso a 0, con lo que se ejecute la macro \textit{unlink} de la línea 22 del Código \ref{code:ptmalloc_vulnerable}. \bigskip

Con lo visto hasta el momento, se obtiene que el \textit{payload} está definido como en la Figura \ref{fig:payload_1}. Tal y como se puede ver, lo único que hay establecido es que el bit menos significativo del campo |size| del segundo fragmento de memoria debe ser 0. Cabe destacar que los campos |prev_size| y |size| del primer fragmento no se pueden controlar ya que no hay modo de sobrescribirlos. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.85]{./Chapters/HeapExploiting/Unlink/payload/img/payload_1.eps}   
    \caption{Payload con el campo size a medio definir}
    \label{fig:payload_1}
\end{figure}

Con los datos expuestos en los parágrafos anteriores, se ha conseguido ejecutar la macro \textit{unlink} al ejecutar el primer |free()|. Ahora falta modificar el \textit{payload} para que al ejecutar \textit{unlink}, se escriban los bytes en las direcciones apropiadas de memoria tal y como se explica en el apartado \ref{sec:attack_vector}. \bigskip

El primer dato necesario es la dirección del inicio de la sección .dtors más 4 bytes. De este modo se sobrescribirá la dirección del destructor existente en el \textit{exploit}. Todos estos conceptos están detallados en el Apéndice \ref{ap:II}. Se obtiene pues, que la dirección que se busca es 0x08049f1c.\\ 
A esta dirección se le han de restar 12 bytes, tal y como se explica en la página \pageref{ref:first_question}, con lo que la dirección que se utilizará finalmente es 0x08049f10. Esta dirección debe ser la que se almacene en el campo |fd| del fragmento de memoria que se sobreescribe, o sea |ptr_2|. \bigskip

Por otro lado, se necesita la dirección del \textit{shellcode} que se utilizará a modo de ejecución de código arbitrario. Debido a las múltiples protecciones de memoria que existen hoy en día, alojar el \textit{shellcode} en una dirección de memoria que sea ejecutable no es trivial. Por esta razón se utiliza la estrategia planteada en el Código \ref{code:chellcode_stratego}. \bigskip

\lstset{language=C, caption=Estrategia para ejecutar el shellcode , label=code:chellcode_stratego}
\begin{lstlisting}
        char shellcode[] = "El shellcode va aqui."

        /* Se obtiene el tamano de las paginas del sistema */
        int pagesize = sysconf(_SC_PAGE_SIZE);
        if ( pagesize == -1) {
                perror("[-] Page size could not be obtained");
                exit(EXIT_FAILURE);
        }
        /* Se obtiene una region de memoria alineada para poder protegerla con mprotect */
        void * real_shell;
        if ( posix_memalign(&real_shell, pagesize, sizeof(shellcode)) ) {
                perror("[+] Aligned memory could not be obtained");
                exit(EXIT_FAILURE);
        }
        /* Se copia el shellcode en la region de memoria ejecutable obtenida con memalign */
        memcpy(real_shell, shellcode, sizeof(shellcode));
        /* Making  shellcode location executable */
        /* Se hace ejecutable la seccion de memoria donde se ubica el shellcode */
        mprotect(real_shell, pagesize, PROT_WRITE | PROT_EXEC);
\end{lstlisting}

La estrategia es la misma que la utilizada para sobrescribir la sección .dtors y está ampliamente explicada en el Apéndice \ref{ap:II}, así que no se entrará en detalles. \\
Gracias al código, se conoce la dirección del \textit{shellcode}, vía el puntero |real_shell|. La dirección donde apunta la variable |real_shell| es lo que ha de contener el campo |bk| del fragmento de memoria que se sobreescribe, o sea, |ptr_2|. \bigskip

De este modo el \textit{payload} queda representado por la Figura \ref{fig:payload_2}. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.85]{./Chapters/HeapExploiting/Unlink/payload/img/payload_2.eps}   
    \caption{Payload con el campo fd y bk definido}
    \label{fig:payload_2}
\end{figure}

Como se puede ver, el campo |fd| contiene la dirección de la sección .dtors más 4 bytes, menos los 12 bytes justificados en la sección \ref{sec:attack_vector}. Por otro lado, el campo |bk| contiene la dirección del \textit{shellcode}. \bigskip

Partiendo de la base que el último dato que queda por concretar es el campo |size| del segundo fragmento y que dicho campo, en el primer |free()| no afecta para nada en la lógica de ejecución del algoritmo, (dejando a parte el tema ya tratado sobre el bit de menos peso y la ejecución de \textit{unlink}) uno se puede aventurar y ponerle cualquier valor. Así pues, el \textit{payload} final, a falta de saber si funcionaría con el segundo |free()|, es el retratado en la Figura \ref{fig:payload_3}. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.85]{./Chapters/HeapExploiting/Unlink/payload/img/payload_3.eps}   
    \caption{Payload final}
    \label{fig:payload_3}
\end{figure}

Como se puede ver, el campo |size| ahora contiene un 0. Evidentemente, el bit menos significativo del valor 0, es 0 con lo que la macro \textit{unlink} se ejecutará entrando en la condición de la línea 21 del Código \ref{code:ptmalloc_vulnerable} tal y como ya se ha explicado. \bigskip