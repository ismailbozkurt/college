\subsubsection{Construcción del payload sin bytes nulos}

En el apartado anterior se ha construido una prueba de concepto de un modo innovador de manera que en ningún otro artículo escrito sobre el tema lo había publicado. Los artículos que tratan esta materia tales como \cite{VAOSBTEMP}, \cite{WSTAE-Pages169-181} o \cite{HOELI} utilizan la técnica que se explicará a continuación, sin embargo, todos esas publicaciones están obsoletas de modo que ninguna de ellas funciona contra el algoritmo \textit{ptmalloc} tal y como está a día de hoy. \\
Todos los artículos citados están basados en el artículo pionero en la materia \cite{VAOSBTEMP}, sin embargo, con los datos proporcionados por dicho artículo es imposible llevar a cabo la explotación del algoritmo. \bigskip

En este capítulo se muestra una revisión de la técnica presentada en \cite{VAOSBTEMP} de modo que la explotación del algoritmo sea completamente funcional. \bigskip

Sin embargo, la pregunta más evidente es ¿porqué revisar la técnica de MaXX si con la técnica mostrada anteriormente ya se cumplían los objetivos? Básicamente por que con la técnica de MaXX es posible evitar el uso de bytes nulos. La problemática que introducen los bytes nulos está ampliamente detallada en \cite{IALEDSESL}, pero en pocas palabras se puede definir que el uso de bytes nulos hace que la copia de bytes en los búfers termine abruptamente si dicha copia se realiza con funciones enfocadas al tratamiento de cadenas tales como |strcpy()|, |strlen()|, etc. \bigskip

La técnica utilizada en este apartado es parecida a la técnica detallada en el capítulo anterior. Se volverá a sobrescribir la sección .dtors con la dirección del \textit{shellcode} que se ejecutará. Sin embargo, esta vez el \textit{payload} será diferente. \\
Tal y como ya se ha visto, en el algoritmo \textit{ptmalloc} para descubrir si los fragmentos están en uso se utiliza el campo |size| del propio fragmento, pero otra cosa muy importante es el hecho de que para conocer dónde empiezan los fragmentos de memoria también se utiliza el campo |size|. Por ejemplo, si se obtiene un fragmento de memoria |p|, el siguiente fragmento de memoria se ubicará en la dirección |p+size|, donde |size| es el tamaño del fragmento |p|.\\
De este modo, si se sobrescribe el campo |size| del segundo fragmento de memoria se puede engañar al algoritmo de tal modo que crea que un fragmento esté situado en una dirección de memoria en la que se pueda escribir, con el objetivo de crear un fragmento de memoria falso con el que se ejecute la macro \textit{unlink}. \bigskip

En la Figura \ref{fig:payload_sin_nulls} se muestra el \textit{payload} final. Como se puede ver, el \textit{payload} es mucho más complejo pero a continuación se detalla el por qué de cada uno de los parámetros que lo definen. \bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=.85]{./Chapters/HeapExploiting/Unlink/payload/img/payload_sin_nulls.eps}   
    \caption{Payload sin null bytes}
    \label{fig:payload_sin_nulls}
\end{figure}

Empezando de atrás en adelante, la explicación es mucho más intuitiva, así que se desarrollará de este modo. \\
El primer valor fuera de lo común en el \textit{payload} es el -16\footnote{En realidad, el valor en complemento a 2 es un -15, sin embargo, cuando se eliminen los 3 bits de menor peso para obtener el tamaño del fragmento se obtendrá un -16.}. Aquí es donde entra en juego la temática del null byte. Lo primero a entender es que con este -16 se hace creer al algoritmo que el siguiente fragmento de memoria se encuentra donde empieza el fragmento 2 ''más'' -16 bytes. Evidentemente se podría haber utilizado un valor positivo y construir el fragmento de memoria falso 16 bytes por encima del fragmento 2, sin embargo, utilizando un valor negativo se evita la introducción de null bytes.\\
Esto se debe a que para representar valores enteros se utiliza una representación conocida como \textit{complemento a 2}\footnote{Para conocer más detalles sobre dicha representación, visitar:\\ \url{http://es.wikipedia.org/wiki/Complemento_a_dos}}. Este sistema permite representar valores tanto positivos como negativos utilizando números binarios. Con esta técnica se aprovecha el hecho de que la representación de números negativos en complemento a 2 se construye a partir de negar todos los bits del valor que se quiere convertir y sumarle uno. Negando todos los bits del valor a convertir se consigue que los bits más significativos del valor tengan sus bits a 1 y no a 0, como ocurre con valores pequeños. \\
A modo de ejemplo, el complemento a 2 el número 8 en una arquitectura de 32 bits se representa como 0x00000008, en cambio, el número -8 se representa como 0xfffffff8. Como se puede ver, el número 8 contiene muchos bytes nulos, mientras que el número -8 no contiene ninguno. \bigskip

Con este -16, cuando se realiza el primer |free()| el flujo del programa acaba en el Código \ref{code:ptmalloc_vulnerable} de la página \pageref{code:ptmalloc_vulnerable}. Después de obtenerse el valor para |nextchunk| que es la dirección del fragmento 2 y su tamaño, -16, se comprueba si el siguiente fragmento al fragmento 2 está en uso. Esto se hace a partir de la macro |inuse_bit_at_offset| definida en el Código \ref{code:inuse_bit_at_offset_macro}. Esta comprobación lleva a definir el tamaño del fragmento falso con un -8. En estos momentos el -8 no tiene justificación, lo que sí la tiene es que eligiendo un -8 el bit |PREV_INUSE| está a 0, con lo que la variable |nextinuse| será 0 y el algoritmo ejecutará la macro \textit{unlink} al entrar en la condición de la línea 21. \\
\underline{De este modo se ha conseguido ejecutar la macro \textit{unlink}} con lo que la sección .dtors se habrá sobrescrito con la dirección del \textit{shellcode} tal y como se ha explicado en los apartados anteriores. \bigskip

Dando por hecho que ya se ha conseguido la ejecución de código arbitrario, a continuación se explica el por qué de los demás detalles del \textit{payload} en orden de participación en el flujo de ejecución. \bigskip

Después del primer |free()|, se ejecuta el |free()| del segundo fragmento. Al ejecutarse las líneas 4 y 5 de Código \ref{code:ptmalloc_vulnerable} se obtiene la dirección del siguiente fragmento a partir del tamaño del fragmento que se está liberando, o sea, -16. De este modo, la variable |nextchunk| apunta al fragmento de memoria falso y la variable |nextsize| almacena el valor -8. \bigskip

Acto seguido se ejecuta la macro |prev_inuse(p)|. El fragmento |p| es el que tiene un tamaño de -16 bytes, pero tal y como se ha apuntado a pie de página anteriormente, el valor real es un -15 debido a que el último bit del campo |size| está a uno. O sea, el bit |PREV_INUSE| está a 1 con lo que no se entrará a la condición de la línea 9 y de este modo se evitará un nuevo \textit{unlink}. \bigskip

La siguiente instrucción relevante es, de nuevo, la de la línea 18, que es la macro |inuse_bit_at_offset()|. Del siguiente fragmento al que apunta |nextchunk|, o sea, el siguiente fragmento al fragmento falso, se obtiene su tamaño. Tal y como ya se ha comentado, al fragmento falso se le ha asignado un tamaño de -8 bytes, con lo que el siguiente fragmento estará a menos -8 bytes a donde apunta |nextchunk|. El campo |size| de este nuevo fragmento falso tiene el bit de menos peso a 1 con lo que no se entrará a la condición de la línea 21 ya que la variable |nextinuse| será 1. De este modo, de nuevo, se evita volver a ejecutar la macro \textit{unlink}. \bigskip

Con esta explicación se detallan todos los datos del \textit{payload}. Evidentemente, todos los datos que no se han comentado pueden contener cualquier valor, evitando, evidentemente, bytes nulos. \bigskip

Tal y como se ha visto, esta técnica es bastante más compleja que la anterior, sin embargo, cuando la situación lo requiera se podrá recurrir a ella. Además, el uso de valores negativos o \textit{desbordamientos de enteros} permite evitar condiciones como la que se encuentra en [malloc.c:4217]. \bigskip