\subsection{Estructura heap\_info}

Un mismo proceso puede tener uno o varios \textit{heaps} dependiendo del número de hilos - o \textit{threads} - del proceso. Es por esta razón que es necesaria una estructura que reúna y gestione este conjunto de \textit{heaps}. Esta estructura se conoce como \textit{heap\_info} y está detallada en el Código \ref{code:heap_info_struct}. \bigskip

\lstset{language=C, caption=heap\_info (arena.c:59), label=code:heap_info_struct}
\begin{lstlisting}
typedef struct _heap_info {
  mstate ar_ptr;            /* Arena for this heap. */
  struct _heap_info *prev;  /* Previous heap. */
  size_t size;              /* Current size in bytes. */
  size_t mprotect_size;     /* Size in bytes that has been mprotected
                               PROT_READ|PROT_WRITE.  */
  /* Make sure the following data is properly aligned, particularly
     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of
     MALLOC_ALIGNMENT. */
  char pad[-6 * SIZE_SZ & MALLOC_ALIGN_MASK];
} heap_info;
\end{lstlisting}

\begin{itemize}
\item \textbf{ar\_ptr}
\begin{myindentpar}{1cm}
La primera variable |ar_ptr| es del tipo |mstate| y se conoce como \textit{arena pointer}. Este tipo está definido en el código ubicado en el fichero \textit{include/malloc.h} tal que así:  

\lstset{language=C, caption=mstate (include/malloc.h:11), label=code:mstate_struct}
\begin{lstlisting}
struct malloc_state;
typedef struct malloc_state *mstate;
\end{lstlisting}

Como se puede ver, |malloc_state| y |mstate| son equivalentes.\\
|mstate| es un puntero a la estructura |malloc_state| y la estructura |malloc_state| está definida en el archivo \textit{malloc.c} y debido a su importancia también se detallará en este apartado.\\
La variable |ar_ptr| hace referencia a la estructura |malloc_state| que es donde se gestionan todos los datos que se almacenen en el \textit{heap}. Esta definición de los datos implica que la relación entre \textit{arenas} y \textit{heaps} es de uno a uno.\bigskip

Tal y como ya se ha comentado, un proceso puede tener varios \textit{heaps}, así que el proceso de uso de los \textit{heaps} se basa en que cuando un proceso necesita almacenar nuevos datos, se busca si existe algún \textit{arena} sin bloquear\footnote{Debido a que \textit{ptmalloc} está implementado para aplicaciones \textit{multithreaded} algunas estructuras de memoria pueden estar bloqueadas con técnicas de gestión de memoria compartida.}, de ser así, se utiliza para almacenar los nuevos datos, de no existir ningún \textit{arena} sin bloquear, se crea un nuevo \textit{heap} y se almacenan los datos en su respectivo \textit{arena}. Esta técnica se utiliza para reducir la problemática conocida como \textit{lock contention}.\cite{MPIAMLE}
\end{myindentpar}

\item \textbf{prev}
\begin{myindentpar}{1cm}
Con la variable |prev| se gestionan todas las estructuras |heap_info| que se crean durante la gestión de la memoria dinámica de un proceso. Como ya se ha comentado, es posible que un mismo proceso tenga múltiples \textit{heaps}. Estos \textit{heaps} se gestionan a través de una lista enlazada de estructuras |heap_info|[arena.c:106]. \\
Sin embargo, dicha variable sólo se utiliza en tres partes del código. La primera es la función |new_heap| [arena.c:693] que crea un nuevo \textit{heap} y devuelve una variable de tipo |heap_info *|, con todo y con eso, la variable |prev| no se inicializa en dicha función. La segunda parte es en la función |heap_trim| [arena.c:840] y, de nuevo, en esta función tampoco se inicializa la variable, sólo se utiliza.
Finalmente, la variable |prev| se inicializa en la función |sYSMALLOc| [malloc.c:2965] después de llamar a la función |new_heap|. Sin embargo, la función |sYSMALLOc| sólo se llama cuando las peticiones de almacenamiento de datos cumplen ciertos requisitos en cuanto al tamaño de los datos, y dichos requisitos pocas veces se cumplen [malloc.c:4747].\\
En pocas palabras, parece que esta variable se utiliza en situaciones marginales y la lógica de su funcionamiento no es muy clara.
\end{myindentpar}

\item \textbf{size}
\begin{myindentpar}{1cm}
En la variable |size| se almacena el tamaño del propio \textit{heap}.
\end{myindentpar}
\end{itemize}

Tanto la variable |pad| como la variable |mprotect_size| no son relevantes y con los comentarios del código fuente hay más que suficiente. \bigskip