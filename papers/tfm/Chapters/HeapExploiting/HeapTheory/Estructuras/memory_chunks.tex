\subsection{Fragmentos de memoria}
\label{sec:memory_chunks}

Los fragmentos de memoria - o \textit{malloc chunks} - es donde se almacenan los datos por los que el usuario ha pedido espacio. Esta estructura de memoria es una de las más importantes ya que dependiendo de cómo se gestionen las operaciones que le afectan es posible que se introduzcan vulnerabilidades en el algoritmo. \bigskip

El código que identifica a los fragmentos de memoria es el siguiente: \bigskip

\lstset{language=C, caption=malloc\_chunk (malloc.c:1809), label=code:malloc_chunk_struct}
\begin{lstlisting}
struct malloc_chunk {
  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      prev_size;
  /* Size in bytes, including overhead. */
  INTERNAL_SIZE_T      size;

  /* double links -- used only if free. */
  struct malloc_chunk* fd;
  struct malloc_chunk* bk;

  /* Only used for large blocks: pointer to next larger size.  */
  /* double links -- used only if free. */
  struct malloc_chunk* fd_nextsize;
  struct malloc_chunk* bk_nextsize;
};
\end{lstlisting}

Como se puede ver por los comentarios del Código \ref{code:malloc_chunk_struct}, hay datos de la propio estructura que sólo se utilizan si el fragmento de memoria está en cierto estado. Esto significa que dependiendo del estado en el que esté el fragmento de memoria, se tendrá una representación ''práctica'' u otra.\\
Un fragmento de memoria sólo puede estar en dos estados. En uso o libre. Tal y como se ha explicado anteriormente, si el fragmento de memoria está libre, su dirección se acabará almacenando en un \textit{bin}. Si el fragmento de memoria está en uso, el usuario obtendrá la dirección de memoria donde podrá almacenar sus datos. \bigskip

Un fragmento de memoria en uso tiene la representación que se muestra en la Figura \ref{fig:malloc_chunk_in_use}.

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=0.6]{./Chapters/HeapExploiting/HeapTheory/Estructuras/img/AllocatedChunk.eps}   
    \caption{Fragmento de memoria en uso}
    \label{fig:malloc_chunk_in_use}
\end{figure}

En la Figura \ref{fig:malloc_chunk_in_use} el puntero |chunk| apunta al principio del fragmento de memoria. La dirección de memoria a la que apunta |chunk| se utiliza por las rutinas internas del algoritmo. Además, justo donde apunta |chunk| se encuentra el tamaño del fragmento de memoria, sólo si dicho fragmento también está en uso. \\
El siguiente campo de la estructura de datos es el tamaño del propio fragmento de memoria. Suponiendo una arquitectura de 32 bits, cada uno de estos campos es de 4 bytes, tal y como se puede comprobar a partir del tipo de cada campo: \bigskip

\lstset{language=C, caption=INTERNAL\_SIZE\_T (malloc.c:385), label=code:INTERNAL_SIZE_T}
\begin{lstlisting}
#ifndef INTERNAL_SIZE_T
#define INTERNAL_SIZE_T size_t
#endif
\end{lstlisting}

Por otro lado, los fragmentos de memoria siempre están alineados a un cierto valor. Esto se debe a que siempre que se hace una llamada a funciones como |malloc()|, el tamaño que se le pasa como argumento a la función es substituido por un tamaño que cumpla ciertos requisitos tal y como se puede ver en las siguientes macros.\bigskip

\pagebreak

\lstset{language=C, caption=checked\_request2size (malloc.c:1955), label=code:checked_request2size}
\begin{lstlisting}
/* pad request bytes into a usable size -- internal version */

#define request2size(req)                                         \
  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK < MINSIZE)  ?             \
   MINSIZE :                                                      \
   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) & ~MALLOC_ALIGN_MASK)

/*  Same, except also perform argument check */

#define checked_request2size(req, sz)                             \
  if (REQUEST_OUT_OF_RANGE(req)) {                                \
    MALLOC_FAILURE_ACTION;                                        \
    return 0;                                                     \
  }                                                               \
  (sz) = request2size(req);
\end{lstlisting}

Como se puede ver, la macro |checked_request2size| - que se ejecuta realizar al peticiones de memoria - devuelve 0 si el tamaño de la petición está fuera de rango y de lo contrario, ejecuta la macro |request2size| que devuelve el tamaño correcto para la petición.\\
El tamaño devuelto será |MIN_SIZE| si el tamaño de la petición es menor al tamaño mínimo permitido. Por contra si el tamaño es mayor al mínimo aceptado, el tamaño devuelto será el tamaño de la petición, más |SIZE_Z|, más |MALLOC_ALIGN_MASK| y a este valor se le realizará una \textit{and} lógica con el valor de |MALLOC_ALIGN_MASK| negado. El valor de dichas constantes se puede ver a continuación:\bigskip

\lstset{language=C, caption=SIZE\_SZ (malloc.c:392), label=code:SIZE_SZ}
\begin{lstlisting}
/* The corresponding word size */
#define SIZE_SZ                (sizeof(INTERNAL_SIZE_T))
\end{lstlisting}

La constante |SIZE_SZ| es igual a 4, ya que |INTERNAL_SIZE_T| equivale al tipo |size_t| que su tamaño en una arquitectura de 32 bits es 4.\bigskip

\lstset{language=C, caption=MALLOC\_ALIGN\_MASK (malloc.c:404), label=code:MALLOC_ALIGN_MASK}
\begin{lstlisting}
#ifndef MALLOC_ALIGNMENT
/* comments */
#define MALLOC_ALIGNMENT       (2 * SIZE_SZ)
#endif

/* The corresponding bit mask value */
#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - 1)
\end{lstlisting}

Se deduce entonces que |MALLOC_ALIGNMENT_MASK| es 7, que en binario se representa como 111. De este modo, y volviendo al Código \ref{code:checked_request2size}, se obtiene que el tamaño devuelto en una petición de memoria que supere el mínimo aceptado siempre será el tamaño inicial de la petición más 4 más 7 y lo más importante es que los últimos tres bits de dicho tamaño siempre serán 0 debido a la \textit{and} lógica que se realiza con el valor de |MALLOC_ALIGN_MASK| negado, que es igual a 29 bits a 1 y los tres bits menos significativos a 0.\\
Gracias a esta estrategia se pueden utilizar los últimos 3 bits de campo que identifica el tamaño del fragmento de memoria como metadatos. Así pues, el bit menos significativo, |P|, de dicho campo sirve para identificar si el fragmento de memoria anterior al actual está en uso. El siguiente bit |M| identifica si el fragmento de memoria actual se ha asignado a través de la llamada al sistema |mmap()| y, por último, el bit |A| sirve para identificar si el fragmento de memoria actual está en un \textit{arena} que no es el principal.\\
Para obtener toda esta información se utilizan las siguientes macros:\bigskip

\lstset{language=C, caption=Metadatos en el campo tamaño (malloc.c:1969), label=code:bit_logic}
\begin{lstlisting}
/* size field is or'ed with PREV_INUSE when previous adjacent chunk in use */
#define PREV_INUSE 0x1

/* extract inuse bit of previous chunk */
#define prev_inuse(p)       ((p)->size & PREV_INUSE)


/* size field is or'ed with IS_MMAPPED if the chunk was obtained with mmap() */
#define IS_MMAPPED 0x2

/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)


/* size field is or'ed with NON_MAIN_ARENA if the chunk was obtained
   from a non-main arena.  This is only set immediately before handing
   the chunk to the user, if necessary.  */
#define NON_MAIN_ARENA 0x4

/* check for chunk from non-main arena */
#define chunk_non_main_arena(p) ((p)->size & NON_MAIN_ARENA)
\end{lstlisting}

Como se puede ver, en todos los casos se utilizan \textit{ands} lógicas para obtener el valor deseado. Si el bit en cuestión está a 1, cada una de las macros devolverá 1, en caso contrario, 0.\\
Por otro lado, para obtener el tamaño del fragmento de memoria se utiliza esta macro:\bigskip

\pagebreak

\lstset{language=C, caption=Tamaño de un fragmento de memoria (malloc.c:1969), label=code:chunk_size}
\begin{lstlisting}
#define SIZE_BITS (PREV_INUSE|IS_MMAPPED|NON_MAIN_ARENA)

/* Get size, ignoring use bits */
#define chunksize(p)         ((p)->size & ~(SIZE_BITS))
\end{lstlisting}

Por último, después del tamaño del fragmento de memoria actual vienen los datos que el usuario ha decidido almacenar. El puntero |mem| apunta al principio de los datos del usuario y dicha dirección es la que se devuelve en las funciones que utiliza el usuario para pedir memoria.\bigskip

A continuación se detalla cómo es un fragmento de memoria libre, o mejor dicho, un fragmento de memoria que ha estado en uso pero que ya se ha liberado. Tal y como se ha explicado anteriormente, la estructura de datos es la misma que con un fragmento de memoria en uso, sin embargo, su representación ''práctica'' es diferente.\\
La Figura \ref{fig:malloc_free_chunk} muestra cual es su representación.\bigskip

\begin{figure}[!htbp]  
    \centering
    \includegraphics[scale=0.6]{./Chapters/HeapExploiting/HeapTheory/Estructuras/img/FreeChunk.eps}   
    \caption{Fragmento de memoria libre}
    \label{fig:malloc_free_chunk}
\end{figure}

De nuevo, en esta representación aparecen los dos campos de tamaño, igual que con el fragmento de memoria en uso, sin embargo, esta vez el segundo bit menos significativo del campo que identifica el tamaño del fragmento actual ya no se utiliza. Esto se debe a que los fragmentos que se han reservado a través de la llamada |mmap()|, una vez liberados, no se almacenan en ningún \textit{bin} debido a que no hay listas que almacenen los fragmentos de memoria reservados con |mmap()|, sino que se liberan con |unmap()| [malloc.c:5060]. \bigskip

\paragraph{} \label{par:adjacent_chunks}
Un dato importante es que los fragmentos de memoria contiguos a este fragmento sólo podrán ser fragmentos de memoria en uso o el fragmento de memoria \textit{top}. Esto significa que nunca se tendrán dos fragmentos de memoria libres contiguos ya que si este es el caso, estos dos fragmentos de memoria libres se fusionarían en un sólo fragmento [malloc.c:2070]. \bigskip

A continuación de los campos de tamaño, se sitúan sendos punteros al próximo y al anterior fragmento de memoria libre respectivamente. Es a partir de estos punteros con los que se navega en busca del fragmento de memoria libre que mejor se adecúe a la petición de memoria del usuario. \\
Un dato muy importante a tener en cuenta es que el puntero |mem|, que es la dirección de memoria que se le devolvió al usuario a través de una llamada, por ejemplo, a |malloc()| ahora apunta directamente a estos dos punteros.\bigskip

Después existen otros dos punteros que identifican el siguiente y el anterior fragmento de memoria de un tamaño mayor al fragmento actual.\bigskip

Y por último, puede existir espacio libre que no se utiliza cuando el fragmento está libre. \bigskip