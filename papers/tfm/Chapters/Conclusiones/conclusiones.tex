\section{Conclusiones}

Al término de la investigación los resultados obtenidos son positivos. El fruto más significativo es la obtención de varias técnicas de explotación del sistema con el que se gestiona la memoria dinámica en el sistema operativo GNU/Linux que no existían o no se habían publicado anteriormente. Evidentemente, este resultado supera con creces las expectativas que se tenían en un principio. \bigskip

El principal problema al llevar a cabo esta investigación ha sido la falta de documentación. En cuanto a la primera parte del trabajo, donde se detallaba exhaustivamente el funcionamiento del \textit{heap}, mayormente la información detallada ha sido extraída del propio código fuente. El único documento existente sobre el tema se puede encontrar en \cite{UTHBBI} que a pesar de ser sólo un \textit{draft} y de ser imposible obtener el trabajo al completo, es el único documento que realmente realiza un buen estudio sobre el algoritmo utilizado para implementar la gestión de la memoria dinámica. Sin duda, ha sido de gran ayuda aun cuando ciertas explicaciones hacían referencia a estructuras de datos desfasadas en comparación a la versión de la \textit{glibc} que se ha tratado en esta investigación. \\
Lo más sorprendente es que ni el desarrollador del algoritmo \textit{ptmalloc2}, ni los programadores de la \textit{glibc} hayan desarrollado ningún tipo de documentación exhaustiva sobre el funcionamiento del algoritmo. \\
A pesar de todas estas dificultades, es justo decir que se ha conseguido dar una idea concisa de cómo se gestiona la memoria dinámica. Y si bien es cierto que muchos conceptos se han obviado, este hecho no ha sido fruto del azar o la ignorancia, sino que la decisión ha sido tomada de manera consciente con el objetivo de darle al lector los conocimientos necesarios para entender todos los conceptos que se iban a tratar en los siguientes capítulos de la investigación. \\
Además, se cree que el modo de detallar las funcionalidades del algoritmo, citando el archivo de código fuente y el número de línea, da confianza al lector para adentrarse por él mismo en el código fuente y poder obtener los conocimientos necesarios para seguir desde el punto donde esta investigación lo ha dejado. Por otro lado, documentar con esta metodología el código fuente que implementa el algoritmo permite al lector comprobar cada una de las afirmaciones hechas en esta investigación, y no son pocas las afirmaciones que contradicen lo publicado en otros artículos de este campo. \bigskip

En cuanto a la segunda parte de esta investigación, tal y como ya se ha comentado, los resultados obtenidos han sido muy satisfactorios. El haber realizado un estudio exhaustivo del algoritmo me ha permitido obtener una visión de conjunto del funcionamiento del \textit{heap}. Del mismo modo, empezar a estudiar las técnicas utilizadas en el pasado para explotar el \textit{heap} hasta llegar a las técnicas más actuales también me ha permitido obtener una visión global del estado del arte. Gracias a este proceso de estudio, conociendo los orígenes e ir evolucionando hasta la actualidad, me ha permitido descubrir una modificación a la técnica de explotación utilizada en el pasado, que con menos requerimientos que las técnicas actuales, tenía las mismas repercusiones. \\
En mi opinión, el descubrimiento de esta modificación de la técnica \textit{unlink}, es trivial, sin embargo, es posible que para llegar a este punto se necesitara obtener la visión de conjunto que se ha mencionado. Sin conocer las técnicas del pasado, cómo se solucionaron y hacia dónde han evolucionado, jamás me hubiera dado cuenta de que con uno de los requisitos de las técnicas actuales se podía vulnerar la solución que utilizaron para neutralizar la técnica \textit{unlink} - la que se utilizaba en el pasado. \bigskip

También es importante darse cuenta de que las técnicas utilizadas para vulnerar el algoritmo encargado de realizar la gestión de la memoria dinámica no sólo son aplicables a este algoritmo. El modo en el que se gestionan los datos en este algoritmo es débil de por si. Una gran lección aprendida a partir de esta investigación es que es muy peligroso mezclar los datos de control del algoritmo con los datos del usuario. La solución a este problema es realmente difícil y posiblemente pase por la implementación de medidas de seguridad a nivel de sistema operativo tales como ASLR. \\
Con esto quiero decir que seguro que existen cientos de algoritmos utilizados en otros lugares que cometen el mismo error y las técnicas plasmadas en esta investigación de bien seguro que se pueden extrapolar a otros algoritmos. \bigskip

Por último, también me gustaría remarcar la importancia del Apéndice \ref{ap:II}. Aun siendo un apéndice, la relevancia de los datos explicados en él es de suma importancia. Los mecanismos introducidos por los desarrolladores del compilador \textit{gcc} han hecho que muchos de los exploits existentes a fecha de hoy se hayan vuelto obsoletos del día a la mañana. Todos aquellos exploits que utilizaban la sobrescritura de la sección .dtors como vector para ejecutar código arbitrario han quedado obsoletos a menos que se hayan amoldado a las nuevas medidas de seguridad implementadas por el compilador. Estas nuevas medidas de seguridad han pasado desapercibidas por la mayoría con lo que existen muy pocas referencias publicadas al respecto. Es por esta razón que publicarlas en una investigación como esta, ayudará a promover el conocimiento de dichas medidas de seguridad.