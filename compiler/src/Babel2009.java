/* Generated By:JavaCC: Do not edit this line. Babel2009.java */
import java.io.*;
import java.util.*;
import taulasimbols.*;

public class Babel2009 implements Babel2009Constants {
  private static FileWriter m_fLex = null;
  private static BufferedWriter m_buffFLex = null;
  private static String m_strNom = null;
  public static TaulaSimbols ts = null;
  public static ASem as = null;
  public static GC gen = null;
  public static Errors oE = null;
  public static CodigoEnsamblador oCE = null;

  public static void main(String [] args)
  {
    try
    {
      if (args.length == 1)
      {
        m_strNom = new String();
        String entrada = new String();
        entrada = args [0].substring(args [0].length() - 3, args [0].length()).toLowerCase(); /*passem a minúscules per evitar problemes*/
        if (entrada.equals("bab"))
        {
          m_strNom = args [0].substring(0, args [0].length() - 3);
          FileInputStream fitxer = new FileInputStream(args [0]);
          m_fLex = new FileWriter(m_strNom + "lex");
          m_buffFLex = new BufferedWriter(m_fLex);
                                        //Fichero de errores	
          oE = Singleton_Error.getInstance(m_strNom + "err");
          //Llamamos a la clase que escribe el codigo por pantalla
          oCE =  Singleton_CE.getInstance(m_strNom + "asm");
                  //Llamada al parser
          Babel2009 elParser = new Babel2009(fitxer);
                  //Creo la instancia de la clase ASem (y dentro se crea la instancia de la TS y el Bloque 0)
                  as = new ASem();
          gen = new GC();
                  elParser.P(); /*Crida al símbol axioma*/
          fitxer.close();
          m_buffFLex.close();
          m_fLex.close();
          oE.tanca(); /*Cal tancar el fitxer!*/
          oCE.tanca();
        }
        else
        {
          System.out.println("Error: necessito un fitxer .bab!");
        }
      }
      else
      {
        System.out.println("Error: Cal passar el fitxer .bab com a argument!");
      }
    }
    catch (Exception e)
    {
      e.printStackTrace(System.err);
      System.out.println(e.getMessage() );
    }
  }

  public static void escriuSortida(Token matchedToken)
  {
    try
    {
      if (
      tokenImage [matchedToken.kind].equals("<ERROR>") ||
      (tokenImage [matchedToken.kind].equals("<IDENTIFICADOR>") &&
      matchedToken.image.length() > 32)
      )
      { /*si hi ha error*/
        if (tokenImage[matchedToken.kind].equals("<ERROR>"))
        {
          oE.errorLexic(Errors.ERR_LEX_1, matchedToken);
        }
        else
        {
          oE.errorLexic(Errors.ERR_LEX_2, matchedToken);
        }
      }
      else
      { /*no hi ha error lèxic <ERROR>*/
        String lexic;
        if (tokenImage [matchedToken.kind].equals("<EOF>"))
        {
          lexic = new String("* Fi de l'an\u00e0lisi *");
        }
        else
        {
          lexic = new String("Token: [" + Babel2009.tokenImage [matchedToken.kind] + "], lexema: [" + matchedToken.image + "]");
        }
        m_buffFLex.write(lexic);
        m_buffFLex.newLine();
        m_buffFLex.flush();
      }
    }
    catch (IOException ioe)
    {
      ioe.printStackTrace(System.err);
    }
  }

  static final public void P() throws ParseException {
 Semantic s = new Semantic();
  CodigoEnsamblador.gc(".text");
  CodigoEnsamblador.gc(".align 2");
  CodigoEnsamblador.gc(".globl main");
    Decl();
    jj_consume_token(PROGRAMA);
    CodigoEnsamblador.gc("main:");
  //Esta mierda era la que me hacia petar el stack!!!!!! Thx to Xavi for the report :P
  //CodigoEnsamblador.gc("move $sp, $fp"); 

    Llista_Inst(s);
    jj_consume_token(FIPROG);
  //Cerramos el programa
  CodigoEnsamblador.gc("# Codigo para cerrar el programa");
  CodigoEnsamblador.gc("li $v0, 10");
  CodigoEnsamblador.gc("syscall");
  CodigoEnsamblador.gc("# Ultima instruccion del main");
  CodigoEnsamblador.gc("jr $ra");

  CodigoEnsamblador.gc("\u005cn\u005cn\u005cn# Codigo para el error en la comprobacion de los limites de un vector");
  CodigoEnsamblador.gc("ERROR:");
  CodigoEnsamblador.gc("li $v0, 4");
  CodigoEnsamblador.gc("la $a0, MERROR");
  CodigoEnsamblador.gc("syscall");
  CodigoEnsamblador.gc("li $v0, 10");
  CodigoEnsamblador.gc("syscall");
  CodigoEnsamblador.gc("# Fin codigo");

  CodigoEnsamblador.gc("\u005cn\u005cn\u005cn# Codigo para el error en la division por cero");
  CodigoEnsamblador.gc("ERROR2:");
  CodigoEnsamblador.gc("li $v0, 4");     //Printf
  CodigoEnsamblador.gc("la $a0, MERROR2"); //Lo que quieres escribir
  CodigoEnsamblador.gc("syscall");
  CodigoEnsamblador.gc("li $v0, 10");
  CodigoEnsamblador.gc("syscall");
  CodigoEnsamblador.gc("# Fin codigo");

  CodigoEnsamblador.gc(".data");
  CodigoEnsamblador.gc(".align 0");

  CodigoEnsamblador.gc("MERROR:");
  CodigoEnsamblador.gc(".asciiz \u005c"[-] Index out of bounds\u005c\u005cn\u005c"");
  CodigoEnsamblador.gc("MERROR2:");
  CodigoEnsamblador.gc(".asciiz \u005c"[-] Division by zero, black hole incoming!\u005c\u005cn\u005c"");
  CodigoEnsamblador.gc("CERT:");
  CodigoEnsamblador.gc(".asciiz \u005c"CERT\u005c"");
  CodigoEnsamblador.gc("FALS:");
  CodigoEnsamblador.gc(".asciiz \u005c"FALS\u005c"");

  CodigoEnsamblador.gc("readedLogic: ");
  CodigoEnsamblador.gc(".space 4 ");
  }

  static final public void Decl() throws ParseException {

    Dec_Cte();

    Dec_Var();

    Dec_Func();

  }

  static final public void Dec_Cte() throws ParseException {
                //Declaraciones:
                Semantic oExp = new Semantic();
                Token oToken;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONST:
      jj_consume_token(CONST);
      jj_consume_token(ID);
    //Recupero el Token actual
        oToken = Babel2009.getToken(0);
      jj_consume_token(IGUAL);
    //Recupero la expresión
    oExp = Exp();
    //Inserto la constante (dentro se harán las verificaciones oportunas)
    as.insertaConstante(oToken,oExp);
      jj_consume_token(PCOMA);
      Dec_Cte();
      break;
    default:
      jj_la1[0] = jj_gen;

    }
  }

  static final public void Dec_Var() throws ParseException {
                //Declaraciones:
                Semantic oSTipus = new Semantic();
                Token oToken;
                ITipus aux=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VAR:
      jj_consume_token(VAR);
    oSTipus = Tipus();
      jj_consume_token(ID);
        //Recupero el Token actual
        oToken = Babel2009.getToken(0);
        //Inserto la variable (dentro se harán las verificaciones oportunas)
    as.insertaVariable(oToken,(ITipus)oSTipus.getValue("TIPUS")); //Aumentar iDesplazamiento dentro del metodo insertaVariable()

      jj_consume_token(PCOMA);
      Dec_Var();
      break;
    default:
      jj_la1[1] = jj_gen;

    }
  }

  static final public void Dec_Func() throws ParseException {
                //Variables
                Funcio oFuncio = new Funcio();
                TaulaSimbols ts = Singleton_TS.getInstance();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FUNCIO:
      jj_consume_token(FUNCIO);
      jj_consume_token(ID);
        //D: Inserto la Funcion en el bloque 0, para que quede registrado el ID de la funcion en las verificaciones a partir de este punto
        oFuncio = as.insertaFuncion(oFuncio,Babel2009.getToken(0));//D: Le pasamos un objeto de tipo Funcio ya construido y el Tipo. Nos devuelve la función insertada (o la función no insertada si es que estaba duplicado)

      jj_consume_token(PARENTOBERT);
        Semantic s = new Semantic();
    Bloc bloc1 = new Bloc();
    ts.inserirBloc(bloc1); // Inserto un nuevo bloque en la tabla de símbolos
    ts.setBlocActual(1); //Establezco el bloque actual a 1

      //D: Se nos devolverá un objeto Funcio para que luego le podamos asignar el tipo a través del ID, y a la vez le pasamos el objeto 'oFuncion' ya inicializado con el nombre para que inserte los parámetros
        oFuncio = Llista_Param(oFuncio);
      jj_consume_token(PARENTTANCAT);
      jj_consume_token(DPUNTS);
      jj_consume_token(TIPUS_SIMPLE);
        as.setTipusFuncion(oFuncio,Babel2009.getToken(0)); //D: Obtengo el tipo y lo modifico
        //D: En este punto ya tengo la función insertada correctamente
        s.setValue("TIPUSFUNCIO",oFuncio);
      jj_consume_token(PCOMA);
      Dec_Cte();
      Dec_Var();
      jj_consume_token(INICI);
    s.setValue("BFUNCIO","CERT");
      //Li passo aquest parametre per controlar el RETORNA
        s = Llista_Inst(s);
      jj_consume_token(FIFUNC);
               as.checkFiFuncio(s,Babel2009.getToken(0));
      jj_consume_token(PCOMA);
    //D: Como se acaba la función, establezco el bloque actual a 0 y borro el bloque 1 de la TS. 
    //D: En el Bloque 0 queda la función y la lista de parámetros
    ts.setBlocActual(0);
    ts.esborrarBloc(1);
    System.out.println("Elimino bloque: " + ts.toXml());
      Dec_Func();
      break;
    default:
      jj_la1[2] = jj_gen;

    }
  }

  static final public Funcio Llista_Param(Funcio oFuncio) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REF:
    case VAL:
      //Le pasamos un objeto Funcio para que lo baje y además lo recuperamos modificado como atributo sintetizado
        oFuncio = Llista_Param_Aux(oFuncio);
                                       {if (true) return oFuncio;}
      break;
    default:
      jj_la1[3] = jj_gen;

     {if (true) return oFuncio;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public Funcio Llista_Param_Aux(Funcio oFuncio) throws ParseException {
                TipusPasParametre oTPasParametre = null;        //En esta variable guardaremos el tipo de paso del parametro
                Semantic oSTipus = new Semantic();
    oTPasParametre = Param_PasParam();
    oSTipus = Tipus();
    jj_consume_token(ID);
        oFuncio = as.insertaParametro(oFuncio,Babel2009.getToken(0),(ITipus)oSTipus.getValue("TIPUS"), oTPasParametre);
    oFuncio = Llista_Mas_Param(oFuncio);
    {if (true) return oFuncio;}
    throw new Error("Missing return statement in function");
  }

  static final public Funcio Llista_Mas_Param(Funcio oFuncio) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMA:
      jj_consume_token(COMA);
      oFuncio = Llista_Param_Aux(oFuncio);
                                                {if (true) return oFuncio;}
      break;
    default:
      jj_la1[4] = jj_gen;

     {if (true) return oFuncio;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public TipusPasParametre Param_PasParam() throws ParseException {
                TipusPasParametre aTipusPasParam=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case REF:
      jj_consume_token(REF);
           {if (true) return aTipusPasParam.REFERENCIA;}
      break;
    case VAL:
      jj_consume_token(VAL);
           {if (true) return aTipusPasParam.VALOR;}
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/*
El vector tiene expresiones que pueden estar usando Identificadores. En la expresión del tipus no sabré
de donde vengo, y tendré que buscar si el ID ha estado declarado o no en ba, y el ba tendría que valer 0,
pq pej si paso un vector de 1..N, la N tendrá que estar declarada en el bloque 0.
Por eso el ba=1 de la cabecera de la funcion no lo puedo hacer antes de bajar a lista de param. 
*/
  static final public Semantic Tipus() throws ParseException {
        Semantic oSemantic1 = new Semantic();
        Semantic oSemantic2 = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TIPUS_SIMPLE:
      jj_consume_token(TIPUS_SIMPLE);
        /* 	Miramos si TIPUS_SIMPLE es un Sencer o es Logic
  		No hay que mirar si es otra cosa pq el Token TIPUS_SIMPLE sólo puede valer estos valores,
  	 	y de no valerlos no hubiésemos entrado en esta parte de la producción.
  	 	Devolvemos un objeto Tipus_Simple que es LOGIC o SENCER.
  	*/
    oSemantic1.setValue("TIPUS", Utils.getTipusSimple(Babel2009.getToken(0).image));
    {if (true) return oSemantic1;}
      break;
    case VECTOR:
      jj_consume_token(VECTOR);
      jj_consume_token(CORXETOBERT);
      oSemantic1 = Exp();
      jj_consume_token(PUNTPUNT);
      oSemantic2 = Exp();
      jj_consume_token(CORXETTANCAT);
      jj_consume_token(DE);
      jj_consume_token(TIPUS_SIMPLE);
    //Llama a la función de verificación del vector (Hará verificaciones y devolverá semantic)
        {if (true) return ASem.insertarVector(oSemantic1,oSemantic2,Babel2009.getToken(0));}
      break;
    case CADENA:
      jj_consume_token(CADENA);
      jj_consume_token(PARENTOBERT);
      oSemantic1 = Exp();
      jj_consume_token(PARENTTANCAT);
        //D: Llama a la función de verificación del vector (Hará verificaciones y devolverá semantic)
    {if (true) return ASem.insertarCadena(oSemantic1,Babel2009.getToken(0));}
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Exp() throws ParseException {
        Semantic s1= new Semantic(); //D: Objetos semantic para mover valores heredando y sintetizando
        Semantic s2= new Semantic();
    s1 = Exp_Simple();
    s2 = Exp_Aux(s1);
  //Si libero aquí las operaciones tales que y = (y*2) - ((y*5)/2); fallan ya que el registro que contiene (y*2) se libera antes de hacer el - ((y*5)/2).
  //if (s1.getValue("REG") != null) {System.out.println("LIBERO S1 -->"); Utils.setReg((String)s1.getValue("REG"));}
  //if (s2.getValue("REG") != null) {System.out.println("LIBERO S2 -->"); Utils.setReg((String)s2.getValue("REG"));}
  {if (true) return s2;}
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Exp_Aux(Semantic s) throws ParseException {
        Semantic osExpSimple = new Semantic();
        Token oToken = new Token();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPER_REL:
      jj_consume_token(OPER_REL);
                oToken = Babel2009.getToken(0);
      osExpSimple = Exp_Simple();
    {if (true) return as.calcularRelacional(s,oToken,osExpSimple);}
      break;
    default:
      jj_la1[7] = jj_gen;

     {if (true) return s;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Exp_Simple() throws ParseException {
        Semantic osOperadorU = new Semantic(); //D: Semantic donde guardare el operador de Operador_Unario
        Semantic osTerme = new Semantic(); //D: Semantic donde guardare el valor sintetizado de Terme
        Semantic osResultUnario = new Semantic(); //D: Semantic donde guardaré el resultado de CalcularUnario para pasarlo a MasTermes
        Semantic osResult = new Semantic();
    osOperadorU = Operador_Unario();
    osTerme = Terme();
        //D: Calculo en función del operador Unario y el término
        //Ya he generado el código para el calculo unario
        osResultUnario = as.calcularUnario(osOperadorU,osTerme,Babel2009.getToken(0)); //D: Le paso el token actual para poder generar el error en caso que lo hubiera

    osResult = Mas_Termes(osResultUnario);
   {if (true) return osResult;}
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Operador_Unario() throws ParseException {
                             Semantic s = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_MAS:
      jj_consume_token(OP_MAS);
              s.setValue("OPER","OP_MAS"); {if (true) return s;}
      break;
    case OP_MENOS:
      jj_consume_token(OP_MENOS);
                s.setValue("OPER","OP_MENOS"); {if (true) return s;}
      break;
    case OP_NOT:
      jj_consume_token(OP_NOT);
              s.setValue("OPER","OP_NOT"); {if (true) return s;}
      break;
    default:
      jj_la1[8] = jj_gen;

      {if (true) return s;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Mas_Termes(Semantic s) throws ParseException {
        Semantic osOperadorB1 = new Semantic();
        Semantic osTerme = new Semantic();
        Semantic osResultB1 = new Semantic();
        Semantic osResult = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_OR:
    case OP_MAS:
    case OP_MENOS:
      osOperadorB1 = Operador_Binario1();
      osTerme = Terme();
        //D: Calculo en función del Semantic recibido, el operador Binario y el Terme
        osResultB1 = as.calcularBinario(s,osOperadorB1,osTerme,Babel2009.getToken(0)); //D: Le paso el token actual para poder generar el error en caso que lo hubiera
  //AQUI QUIZÁ DEBERÍA LIBERAR EL REGISTRO DE S!!!!!!!!!!!!!!!!!!!!!!!!!!
 // 				if (s.getValue("REG") != null) {System.out.println("(T) FREE S AFTER CALCULARBINARIO() -->"); Utils.setReg((String)s.getValue("REG"));}

      osResult = Mas_Termes(osResultB1);
  //				if (osTerme.getValue("REG") != null) {System.out.println("LIBERO OSTERME -->"); Utils.setReg((String)osTerme.getValue("REG"));}
  {if (true) return osResult;}
      break;
    default:
      jj_la1[9] = jj_gen;

     {if (true) return s;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Operador_Binario1() throws ParseException {
                               Semantic s = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_OR:
      jj_consume_token(OP_OR);
             s.setValue("OPER","OP_OR"); {if (true) return s;}
      break;
    case OP_MENOS:
      jj_consume_token(OP_MENOS);
                s.setValue("OPER","OP_MENOS"); {if (true) return s;}
      break;
    case OP_MAS:
      jj_consume_token(OP_MAS);
              s.setValue("OPER","OP_MAS"); {if (true) return s;}
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Terme() throws ParseException {
        Semantic osFactor = new Semantic();
        Semantic osResult = new Semantic();
    osFactor = Factor();
    osResult = Mas_Factores(osFactor);
   {if (true) return osResult;}
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Mas_Factores(Semantic s) throws ParseException {
        Semantic osOperadorB2 = new Semantic();
        Semantic osFactor = new Semantic();
        Semantic osResultB2 = new Semantic();
        Semantic osResult = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_AND:
    case OP_MUL:
    case OP_DIV:
    case OP_CONCAT:
      osOperadorB2 = Operador_Binario2();
      osFactor = Factor();
        //D: Calculo en función del Semantic recibido, el operador Binario y el Factor
        osResultB2 = as.calcularBinario(s,osOperadorB2,osFactor,Babel2009.getToken(0)); //D: Le paso el token actual para poder generar el error en caso que lo hubiera
  //AQUÍ QUIZÁ DEBERÍA LIBERAR EL REGISTRO DE S!
  //Si libero aquí en operaciones como y = x * 2 - 6; o y = (x*2)-6; se libera el registro que contiene el resultado de x*2 y falla!
  //if (s.getValue("REG") != null) {System.out.println("(F)FREE S AFTER CALCULARBINARIO() -->"); Utils.setReg((String)s.getValue("REG"));}	

      osResult = Mas_Factores(osResultB2);
  //ESTO SOLUCIONA EL PROBLEMA, PERO NO FUNCIONA GENERALMENTE (SUPONGO!!!)
  //if (osResult.getValue("REG") != null) {System.out.println("(F)FREE S AFTER CALCULARBINARIO() -->"); Utils.setReg((String)osResult.getValue("REG"));}
  {if (true) return osResult;}
      break;
    default:
      jj_la1[11] = jj_gen;

     {if (true) return s;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Operador_Binario2() throws ParseException {
                               Semantic s = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OP_AND:
      jj_consume_token(OP_AND);
              s.setValue("OPER","OP_AND"); {if (true) return s;}
      break;
    case OP_DIV:
      jj_consume_token(OP_DIV);
              s.setValue("OPER","OP_DIV"); {if (true) return s;}
      break;
    case OP_MUL:
      jj_consume_token(OP_MUL);
              s.setValue("OPER","OP_MUL"); {if (true) return s;}
      break;
    case OP_CONCAT:
      jj_consume_token(OP_CONCAT);
                 s.setValue("OPER","OP_CONCAT"); {if (true) return s;}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Factor() throws ParseException {
 Semantic s=new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CTE_ENTERA:
      jj_consume_token(CTE_ENTERA);
                        {if (true) return as.makeCteEntera(Babel2009.getToken(0));}
      break;
    case CTE_LOGICA:
      jj_consume_token(CTE_LOGICA);
                        {if (true) return as.makeCteLogica(Babel2009.getToken(0));}
      break;
    case CTE_CADENA:
      jj_consume_token(CTE_CADENA);
                        {if (true) return as.makeCteCadena(Babel2009.getToken(0));}
      break;
    case PARENTOBERT:
      jj_consume_token(PARENTOBERT);
                   Semantic osExp = new Semantic();
      osExp = Exp();
      jj_consume_token(PARENTTANCAT);
    {if (true) return osExp;}
      break;
    case TRIM:
      jj_consume_token(TRIM);
      jj_consume_token(PARENTOBERT);
      s = Exp();
      jj_consume_token(PARENTTANCAT);
                                                      {if (true) return as.makeTrimCadena(s,Babel2009.getToken(0));}
      break;
    case ID:
      jj_consume_token(ID);
           Semantic osLL1 = new Semantic();
      osLL1 = LL1(Babel2009.getToken(0));
    s = osLL1;
  //Pongo este if que no esta en los apuntes porque cuando es el valor de una constante, no tenemos registro y esto peta! 
  if (osLL1.getValue("REG") != null)
            s.setValue("REG", (String) osLL1.getValue("REG"));
    {if (true) return s;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic LL1(Token oToken) throws ParseException {
        Semantic osFuncion = new Semantic();
        Semantic osVectorOVar = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PARENTOBERT:
      jj_consume_token(PARENTOBERT);
                    osFuncion = as.checkEsFuncion(oToken);
      LParam_Reales(osFuncion);
      jj_consume_token(PARENTTANCAT);
        {if (true) return as.retornaSemFuncion(osFuncion);} //D: Devuelvo un Semantic con el tipo de la función, estática a FALSO y valor NULO pq no es estática

      break;
    default:
      jj_la1[14] = jj_gen;
      osVectorOVar = Variable_Aux(oToken);
  //No comentar, sino la DIR es nula cuando tenemos una constante. Esta en los apuntes de la Tona, no del Xavi
  if ( ((String) osVectorOVar.getValue("ESTATIC")).compareTo("FALS") == 0 ) {
          String Registro = Utils.getReg();
          CodigoEnsamblador.gc("# Codigo del punto (3) de expresiones (no estatico)");
    CodigoEnsamblador.gc("lw "+Registro+", "+(String)osVectorOVar.getValue("DIR"));
    CodigoEnsamblador.gc("# Fin codigo");
    osVectorOVar.setValue("REG", Registro);
    //Utils.setReg(Registro);
  }
    {if (true) return osVectorOVar;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public void LParam_Reales(Semantic osFuncion) throws ParseException {
                                          Semantic s=new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TRIM:
    case CTE_LOGICA:
    case CTE_ENTERA:
    case CTE_CADENA:
    case OP_NOT:
    case OP_MAS:
    case OP_MENOS:
    case PARENTOBERT:
    case ID:
          s=osFuncion; s.setValue("COUNTP",0);
      LParamR(s);
      break;
    default:
      jj_la1[15] = jj_gen;

       as.checkFuncionSinParametros(osFuncion);
    }
  }

  static final public void LParamR(Semantic osFuncion) throws ParseException {
                                   Semantic osExpParametro=new Semantic(); Semantic s=new Semantic();
    osExpParametro = Exp();
        s = osFuncion; //En ete punto osFuncion tiene tanto el contador como el objeto funcion
        s.setValue("COUNTP",((Integer)s.getValue("COUNTP"))+1);  //Incremento contador de parámetros de bajada
        as.checkFuncionParametro(s,osExpParametro); //TODO: Verifico límites de parametros y tipos

    Mas_Param(osFuncion);
  }

  static final public void Mas_Param(Semantic osFuncion) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMA:
      jj_consume_token(COMA);
      LParamR(osFuncion);

      break;
    default:
      jj_la1[16] = jj_gen;

       as.checkFuncionFinParametros(osFuncion);
    }
  }

  static final public Semantic Variable_Aux(Token oToken) throws ParseException {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Semantic s = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CORXETOBERT:
      jj_consume_token(CORXETOBERT);
      s = Exp();
      jj_consume_token(CORXETTANCAT);
  //(2.1) Código para verificar que LI <= exp.reg <= LS
  gen.verificaLimitesVector(s, oToken);
  //(2.2) Código para calcular la dirección del elemento
        //Modifico s ya que dentro del método cambio el parámetro DIR del semántico
  s = gen.calculaDireccionAccesoVector(s, oToken);
  {if (true) return as.checkVector(oToken,s);}              //Verifico que ID es vector y retorno semantic con 3 atributos 

      break;
    default:
      jj_la1[17] = jj_gen;

   {if (true) return as.checkEsCteVar(oToken);}
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Llista_Inst(Semantic osH) throws ParseException {
        Semantic s1 = new Semantic();
        Semantic s2 = new Semantic();
    s1 = Inst(osH);
    jj_consume_token(PCOMA);
    s2 = Mas_Inst(s1);
                                             {if (true) return s2;}
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Mas_Inst(Semantic sh) throws ParseException {
 Semantic s = new Semantic();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CICLE:
    case ESCRIURE:
    case LLEGIR:
    case PER:
    case RETORNAR:
    case SI:
    case SURTCICLE:
    case ID:
      s = Llista_Inst(sh);
                        {if (true) return s;}
      break;
    default:
      jj_la1[18] = jj_gen;

       {if (true) return sh;}
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Inst(Semantic osH) throws ParseException {
        Semantic osSem1 = new Semantic();
        Semantic osSem2 = new Semantic();
        Semantic osOper = new Semantic();
        Token oToken = new Token();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ID:
      jj_consume_token(ID);
          oToken = Babel2009.getToken(0);
      osSem1 = Variable_Aux(oToken);
      osOper = Oper_Asig();
      osSem2 = Exp();
    as.checkAssign(osSem1,osOper,osSem2,oToken); {if (true) return osH;}
      break;
    case ESCRIURE:
      jj_consume_token(ESCRIURE);
      jj_consume_token(PARENTOBERT);
      LExp_Escriure();
      jj_consume_token(PARENTTANCAT);
                                                                   {if (true) return osH;}
      break;
    case LLEGIR:
      jj_consume_token(LLEGIR);
      jj_consume_token(PARENTOBERT);
      LVar_Llegir();
      jj_consume_token(PARENTTANCAT);
                                                              {if (true) return osH;}
      break;
    case CICLE:
      jj_consume_token(CICLE);
  /* Creem objecte semantic amb bClicle=TRUE  */ osSem1.setValue("BCICLE","CERT");
  /* GC: Generación de codigo para la instrucción cicle */
  String Eti1 = Utils.getEtiqueta();
  String Eti2 = Utils.getEtiqueta();
  CodigoEnsamblador.gc("# Codigo inicial de la instruccion cicle");
  CodigoEnsamblador.gc(Eti1+":");
  CodigoEnsamblador.gc("# Fin codigo");
  osSem1.setValue("ETI", Eti2);
  /* 	       FIN GC         */

      osSem2 = Llista_Inst(osSem1);
      jj_consume_token(FICICLE);
                                /* En realitat no cal fer res, pq ja es el surtcicle el que fa la comprovacio de BLCICLE. L'únic que ens pot donar error semantic es el SURTCICLE  */
                                as.checkWarningCicle(osSem2,Babel2009.getToken(0));
                                /* GC: Codigo final de la instrucción cicle */
                                CodigoEnsamblador.gc("# Codigo final de la instruccion cicle");
                                CodigoEnsamblador.gc("b "+Eti1);
                                CodigoEnsamblador.gc(Eti2+":");
                                CodigoEnsamblador.gc("#Fin codigo");
                                /*             FIN GC            */
                                {if (true) return osH;}
      break;
    case SI:
      jj_consume_token(SI);
      osSem1 = Exp();
                          as.checkSi(osSem1,Babel2009.getToken(0));
      jj_consume_token(LLAVORS);
  /*   GC: CODIGO DEL IF */
  String Eti4 = Utils.getEtiqueta();
  String RegOperacional = null;
  CodigoEnsamblador.gc("# Codigo del punto (1) del si");
  if ( (RegOperacional = (String)osSem1.getValue("REGOPERACIONAL")) != null) {
     CodigoEnsamblador.gc("beqz "+RegOperacional+", "+Eti4);
  }
  CodigoEnsamblador.gc("# Fin codigo del punto (1) del si");
  Utils.setReg(RegOperacional);
  /*   GC: FIN CODIGO IF */

      Llista_Inst(osH);
  CodigoEnsamblador.gc("# Codigo del punto (2) del si");
  String Eti5 = Utils.getEtiqueta();
  CodigoEnsamblador.gc("b "+Eti5);
  CodigoEnsamblador.gc(Eti4+":");
  CodigoEnsamblador.gc("# Fin codigo del punto (2) del si");
      Inst_Sino(osH);
      jj_consume_token(FISI);
  CodigoEnsamblador.gc("# Codigo del punto (3) del si");
  CodigoEnsamblador.gc(Eti5+":");
  CodigoEnsamblador.gc("# Fin codigo del punto (3) del si");
  {if (true) return osH;}
      break;
    case SURTCICLE:
      jj_consume_token(SURTCICLE);
  /* GC para salir de la instruccion cicle */
  String Eti3 = null;
  if ( osH.getValue("ETI") instanceof String ) {
     if ( (Eti3 = (String) osH.getValue("ETI")) != null ) {
          CodigoEnsamblador.gc("# Codigo para el surtcicle");
          CodigoEnsamblador.gc("b "+Eti3);
          CodigoEnsamblador.gc("# Fin codigo surtcicle");
     }
  }
  /*               FIN GC                  */
  /* Verificar que BCICLE==true */
  {if (true) return as.checkSurticicle(osH,Babel2009.getToken(0));}
      break;
    case RETORNAR:
      jj_consume_token(RETORNAR);
      osSem1 = Exp();
                                as.checkRetornar(osH,Babel2009.getToken(0),osSem1); {if (true) return osH;}
      break;
    case PER:
      jj_consume_token(PER);
      jj_consume_token(ID);
                  oToken = Babel2009.getToken(0);
      jj_consume_token(IGUAL);
      osSem1 = Exp();
      jj_consume_token(A);
  //Punto (1) del per
  String Eti6 = Utils.getEtiqueta();
  CodigoEnsamblador.gc("# Codigo del punto (1) del PER");
  //Metodo para el calculo de la direccion de un ID.
  //Utilizo el método de variableaux() cuando va por lambda que me devuelve al dirección de un ID cualquiera.
  Semantic osIDAddress = as.checkEsCteVar(oToken);
  CodigoEnsamblador.gc("# Codigo para asignar el valor de EXP al ID");
  String sDir = null;
  if ( (sDir = (String) osIDAddress.getValue("DIR")) != null) {
    if ( osSem1.getValue("REG") != null ) {
      CodigoEnsamblador.gc("sw "+(String)osSem1.getValue("REG")+", "+sDir);
    } else {
      if (osSem1.getValue("VALOR") != null ) {
        String Rtemp = Utils.getReg();
        CodigoEnsamblador.gc("li "+Rtemp+", "+osSem1.getValue("VALOR"));
        CodigoEnsamblador.gc("sw "+Rtemp+", "+sDir);
        Utils.setReg(Rtemp);
      }
    }
  }
  String Rtemp2 = Utils.getReg();
  CodigoEnsamblador.gc(Eti6+":");
      osSem2 = Exp();
                   as.checkPer(oToken,osSem1,osSem2);
      jj_consume_token(FER);
  //Punto (2) del per
  CodigoEnsamblador.gc("# Codigo del punto (2) del PER");
  String Eti7 = Utils.getEtiqueta();
  CodigoEnsamblador.gc("# Codigo para recuperar el valor de ID en cada vuelta y compararlo");
  CodigoEnsamblador.gc("lw "+Rtemp2+", "+sDir);
  if ( osSem2.getValue("REG") != null) {
    CodigoEnsamblador.gc("bgt "+Rtemp2+", "+(String)osSem2.getValue("REG")+", "+Eti7);
  } else {
    if ( osSem2.getValue("VALOR") != null) {
          String Rtemp3 = Utils.getReg();
          CodigoEnsamblador.gc("li "+Rtemp3+", "+osSem2.getValue("VALOR"));
      CodigoEnsamblador.gc("bgt "+Rtemp2+", "+Rtemp3+", "+Eti7);
      Utils.setReg(Rtemp3);
    }
  }
  Utils.setReg(Rtemp2);
      Llista_Inst(osH);
  //Punto (3) del per
  CodigoEnsamblador.gc("# Codigo del punto (3) del PER");
  String Rtemp4 = Utils.getReg();
  CodigoEnsamblador.gc("lw "+Rtemp4+", "+sDir);
  CodigoEnsamblador.gc("addi "+Rtemp4+", "+Rtemp4+", 1");
  CodigoEnsamblador.gc("sw "+Rtemp4+", "+sDir);
  CodigoEnsamblador.gc("b "+Eti6);
  Utils.setReg(Rtemp4);
      jj_consume_token(FIPER);
  //Punto (4) del per
  CodigoEnsamblador.gc("#Codigo del punto (4) del PER. Fin");
  CodigoEnsamblador.gc(Eti7+":");
  {if (true) return osH;}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Semantic Oper_Asig() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IGUAL:
      jj_consume_token(IGUAL);
             {if (true) return as.getAssignOperator(Babel2009.getToken(0));}
      break;
    case MENOSIGUAL:
      jj_consume_token(MENOSIGUAL);
                  {if (true) return as.getAssignOperator(Babel2009.getToken(0));}
      break;
    case MASIGUAL:
      jj_consume_token(MASIGUAL);
                {if (true) return as.getAssignOperator(Babel2009.getToken(0));}
      break;
    case CONCATIGUAL:
      jj_consume_token(CONCATIGUAL);
                   {if (true) return as.getAssignOperator(Babel2009.getToken(0));}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public void Inst_Sino(Semantic osH) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SINO:
      jj_consume_token(SINO);
      Llista_Inst(osH);
      break;
    default:
      jj_la1[21] = jj_gen;

    }
  }

  static final public void LExp_Escriure() throws ParseException {
  Semantic osS = new Semantic();
    osS = Exp();
                as.checkEscriure(osS,Babel2009.getToken(0));
    Mas_Exp();
  }

  static final public void Mas_Exp() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMA:
      jj_consume_token(COMA);
      LExp_Escriure();
      break;
    default:
      jj_la1[22] = jj_gen;

    }
  }

  static final public void LVar_Llegir() throws ParseException {
        Semantic osS = new Semantic();
        Token oToken = new Token();
    oToken = jj_consume_token(ID);
    osS = Variable_Aux(Babel2009.getToken(0));
                                                              as.checkLlegir(osS,oToken);
    Mas_Var();
  }

  static final public void Mas_Var() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMA:
      jj_consume_token(COMA);
      LVar_Llegir();
      break;
    default:
      jj_la1[23] = jj_gen;

    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public Babel2009TokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[24];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x800,0x0,0x100000,0x4000000,0x0,0x4000000,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x80000000,0x0,0x0,0x59802400,0x59802400,0x0,0x20000000,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x2,0x0,0x1,0x1000000,0x1,0x84,0x40,0x1c00,0x1a00,0x1a00,0xe100,0xe100,0x10400038,0x400000,0x10401c38,0x1000000,0x2000000,0x10000000,0x10000000,0xf0000,0x0,0x1000000,0x1000000,};
   }

  /** Constructor with InputStream. */
  public Babel2009(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Babel2009(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new Babel2009TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public Babel2009(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new Babel2009TokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public Babel2009(Babel2009TokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(Babel2009TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 24; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[64];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 24; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 64; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
